I'll create the binary file for device_C.bin with the wrong endianness. Based on typical embedded systems, I'll assume device_C should be little-endian but write it in big-endian format.

Let me generate realistic values that are valid when properly interpreted but invalid when byte-swapped:
- Device type: 3000 (0x0BB8) - valid range typically 1000-5000
- Threshold: 2.5 - valid range 0.1-10.0
- Frequency: 50000 Hz - valid range 10000-100000
- Mode: 7 - valid range 0-15
- Scale: 0.75 - valid range 0.1-2.0

Writing in BIG-ENDIAN (wrong for this device):

Device type (16-bit): 3000 = 0x0BB8 → bytes: 0x0B 0xB8
Threshold (32-bit float): 2.5 = 0x40200000 → bytes: 0x40 0x20 0x00 0x00
Frequency (32-bit int): 50000 = 0x0000C350 → bytes: 0x00 0x00 0xC3 0x50
Mode (16-bit): 7 = 0x0007 → bytes: 0x00 0x07
Scale (32-bit float): 0.75 = 0x3F400000 → bytes: 0x3F 0x40 0x00 0x00

Total: 18 bytes