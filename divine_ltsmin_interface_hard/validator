#!/usr/bin/env python3

import struct
import sys
import os

def read_current_format(filename):
    """Read the current binary format from the file."""
    states = []
    with open(filename, 'rb') as f:
        # Read header
        magic = f.read(4)
        if magic != b'STAT':
            print("Error: Invalid magic number", file=sys.stderr)
            return None
        
        version = struct.unpack('<I', f.read(4))[0]
        count = struct.unpack('<I', f.read(4))[0]
        
        # Read each state vector
        for i in range(count):
            # Current format appears to be:
            # - state_id: 4 bytes (uint32)
            # - timestamp: 8 bytes (uint64)
            # - num_transitions: 4 bytes (uint32)
            # - flags: 4 bytes (uint32)
            # - data_size: 4 bytes (uint32)
            # - data: variable length bytes
            
            state_id = struct.unpack('<I', f.read(4))[0]
            timestamp = struct.unpack('<Q', f.read(8))[0]
            num_transitions = struct.unpack('<I', f.read(4))[0]
            flags = struct.unpack('<I', f.read(4))[0]
            data_size = struct.unpack('<I', f.read(4))[0]
            data = f.read(data_size)
            
            states.append({
                'state_id': state_id,
                'timestamp': timestamp,
                'num_transitions': num_transitions,
                'flags': flags,
                'data': data
            })
    
    return {'version': version, 'count': count, 'states': states}

def write_correct_format(filename, data):
    """Write data in the correct format expected by the validator."""
    with open(filename, 'wb') as f:
        # Write header
        f.write(b'STAT')
        f.write(struct.pack('<I', data['version']))
        f.write(struct.pack('<I', data['count']))
        
        # The correct format based on typical alignment requirements:
        # Header should be followed by padding to 16-byte boundary
        f.write(b'\x00' * 4)  # Padding to align to 16 bytes
        
        for state in data['states']:
            # Correct format for each state vector:
            # - state_id: 4 bytes (uint32)
            # - flags: 4 bytes (uint32) - MOVED BEFORE timestamp
            # - timestamp: 8 bytes (uint64) - needs 8-byte alignment
            # - num_transitions: 4 bytes (uint32)
            # - data_size: 4 bytes (uint32)
            # - data: variable length
            # - padding to 8-byte boundary
            
            f.write(struct.pack('<I', state['state_id']))
            f.write(struct.pack('<I', state['flags']))  # Reordered
            f.write(struct.pack('<Q', state['timestamp']))  # Now aligned
            f.write(struct.pack('<I', state['num_transitions']))
            f.write(struct.pack('<I', len(state['data'])))
            f.write(state['data'])
            
            # Pad to 8-byte boundary
            data_len = len(state['data'])
            padding_needed = (8 - (data_len % 8)) % 8
            if padding_needed > 0:
                f.write(b'\x00' * padding_needed)

def main():
    input_file = '/workspace/state-exchange/sample_states.bin'
    output_file = '/workspace/state-exchange/sample_states_fixed.bin'
    
    if not os.path.exists(input_file):
        print(f"Error: Input file {input_file} not found", file=sys.stderr)
        sys.exit(1)
    
    print("Reading current format...")
    data = read_current_format(input_file)
    
    if data is None:
        print("Failed to read input file", file=sys.stderr)
        sys.exit(1)
    
    print(f"Found {data['count']} state vectors")
    
    print("Converting to correct format...")
    write_correct_format(output_file, data)
    
    print(f"Conversion complete. Output written to {output_file}")
    return 0

if __name__ == '__main__':
    sys.exit(main())