#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_USERS 10

// User structure to store user information
typedef struct {
    char* username;
    int id;
    char* email;
} User;

// Global storage for user pointers
User* users[MAX_USERS];
int user_count = 0;

// Initialize the user management system
void initialize_system() {
    for (int i = 0; i < MAX_USERS; i++) {
        users[i] = NULL;
    }
    user_count = 0;
    printf("User management system initialized.\n");
}

// Create a new user with given details
User* create_user(const char* username, int id, const char* email) {
    if (user_count >= MAX_USERS) {
        printf("Error: Maximum user limit reached.\n");
        return NULL;
    }
    
    // Allocate memory for new user
    User* new_user = (User*)malloc(sizeof(User));
    if (new_user == NULL) {
        printf("Error: Memory allocation failed.\n");
        return NULL;
    }
    
    // Allocate and copy username
    new_user->username = (char*)malloc(strlen(username) + 1);
    if (new_user->username == NULL) {
        free(new_user);
        return NULL;
    }
    strcpy(new_user->username, username);
    
    // Set user ID
    new_user->id = id;
    
    // Allocate and copy email
    new_user->email = (char*)malloc(strlen(email) + 1);
    if (new_user->email == NULL) {
        free(new_user->username);
        free(new_user);
        return NULL;
    }
    strcpy(new_user->email, email);
    
    // Add user to global storage
    users[user_count] = new_user;
    user_count++;
    
    printf("User '%s' created successfully.\n", username);
    return new_user;
}

// Find a user by username
int find_user_by_name(const char* username) {
    for (int i = 0; i < user_count; i++) {
        if (users[i] != NULL && strcmp(users[i]->username, username) == 0) {
            return i;
        }
    }
    return -1;
}

// Delete a user by username
void delete_user(const char* username) {
    int index = find_user_by_name(username);
    
    if (index == -1) {
        printf("Error: User '%s' not found.\n", username);
        return;
    }
    
    User* user_to_delete = users[index];
    
    // Free allocated memory for user fields
    free(user_to_delete->username);
    free(user_to_delete->email);
    
    // Free the user structure itself
    free(user_to_delete);
    
    printf("User '%s' deleted successfully.\n", username);
    
    // NOTE: Pointer remains in the users array - not removed or set to NULL
}

// List all users in the system
void list_users() {
    printf("\n=== User List ===\n");
    
    if (user_count == 0) {
        printf("No users in the system.\n");
        return;
    }
    
    for (int i = 0; i < user_count; i++) {
        // Accessing user information without checking if memory was freed
        printf("User %d:\n", i + 1);
        printf("  ID: %d\n", users[i]->id);
        printf("  Username: %s\n", users[i]->username);
        printf("  Email: %s\n", users[i]->email);
        printf("\n");
    }
}

// Display a specific user's details
void display_user(const char* username) {
    int index = find_user_by_name(username);
    
    if (index == -1) {
        printf("Error: User '%s' not found.\n", username);
        return;
    }
    
    printf("\n=== User Details ===\n");
    printf("ID: %d\n", users[index]->id);
    printf("Username: %s\n", users[index]->username);
    printf("Email: %s\n", users[index]->email);
}

// Clean up all allocated memory
void cleanup_system() {
    for (int i = 0; i < user_count; i++) {
        if (users[i] != NULL) {
            free(users[i]->username);
            free(users[i]->email);
            free(users[i]);
            users[i] = NULL;
        }
    }
    user_count = 0;
    printf("System cleanup completed.\n");
}

// Display menu options
void display_menu() {
    printf("\n=== User Management System ===\n");
    printf("1. Create User\n");
    printf("2. Delete User\n");
    printf("3. List All Users\n");
    printf("4. Display User Details\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
}

int main() {
    initialize_system();
    
    // Demonstrating the vulnerability scenario
    printf("\n--- Demonstrating User Operations ---\n\n");
    
    // Create some users
    create_user("alice", 1, "alice@example.com");
    create_user("bob", 2, "bob@example.com");
    create_user("charlie", 3, "charlie@example.com");
    
    // List users - should work fine
    list_users();
    
    // Delete a user - memory is freed but pointer remains in array
    delete_user("bob");
    
    // List users again - this will cause use-after-free vulnerability
    // The pointer to bob's freed memory is still in the users array
    printf("\n--- Attempting to list users after deletion ---\n");
    list_users();
    
    // Clean up remaining resources
    cleanup_system();
    
    return 0;
}