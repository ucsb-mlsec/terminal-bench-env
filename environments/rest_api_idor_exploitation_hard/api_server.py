#!/usr/bin/env python3

from flask import Flask, request, jsonify, g
import sqlite3
import secrets
import hashlib
from functools import wraps
from datetime import datetime, timedelta

app = Flask(__name__)
app.config['SECRET_KEY'] = 'dev-secret-key-change-in-production'

DATABASE = '/tmp/customer_api.db'

# Token storage (in production, use Redis or database)
active_tokens = {}

def get_db():
    """Get database connection"""
    db = getattr(g, '_database', None)
    if db is None:
        db = g._database = sqlite3.connect(DATABASE)
        db.row_factory = sqlite3.Row
    return db

@app.teardown_appcontext
def close_connection(exception):
    """Close database connection on teardown"""
    db = getattr(g, '_database', None)
    if db is not None:
        db.close()

def init_db():
    """Initialize database with users table and test data"""
    conn = sqlite3.connect(DATABASE)
    cursor = conn.cursor()
    
    # Create users table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            username TEXT UNIQUE NOT NULL,
            email TEXT NOT NULL,
            password TEXT NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Insert test users
    test_users = [
        (1001, 'alice', 'alice@example.com', 'alicepass'),
        (1002, 'bob', 'bob@example.com', 'bobpass')
    ]
    
    try:
        cursor.executemany(
            'INSERT INTO users (user_id, username, email, password) VALUES (?, ?, ?, ?)',
            test_users
        )
        conn.commit()
    except sqlite3.IntegrityError:
        # Users already exist
        pass
    
    conn.close()

def hash_password(password):
    """Hash password using SHA256"""
    return hashlib.sha256(password.encode()).hexdigest()

def generate_token():
    """Generate secure random token"""
    return secrets.token_hex(32)

def require_auth(f):
    """Decorator to require authentication"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        token = request.headers.get('Authorization')
        
        if not token:
            return jsonify({'error': 'Missing authorization token'}), 401
        
        if token.startswith('Bearer '):
            token = token[7:]
        
        if token not in active_tokens:
            return jsonify({'error': 'Invalid or expired token'}), 401
        
        # Store current user info in request context
        g.current_user = active_tokens[token]
        return f(*args, **kwargs)
    
    return decorated_function

@app.route('/api/login', methods=['POST'])
def login():
    """
    Login endpoint - authenticates user and returns access token
    
    Expected JSON body:
    {
        "username": "alice",
        "password": "alicepass"
    }
    """
    data = request.get_json()
    
    if not data or 'username' not in data or 'password' not in data:
        return jsonify({'error': 'Missing username or password'}), 400
    
    username = data['username']
    password = data['password']
    
    db = get_db()
    cursor = db.cursor()
    
    # Authenticate user
    cursor.execute(
        'SELECT user_id, username, email FROM users WHERE username = ? AND password = ?',
        (username, password)
    )
    
    user = cursor.fetchone()
    
    if not user:
        return jsonify({'error': 'Invalid credentials'}), 401
    
    # Generate access token
    token = generate_token()
    
    # Store token with user info
    active_tokens[token] = {
        'user_id': user['user_id'],
        'username': user['username'],
        'email': user['email'],
        'expires_at': datetime.now() + timedelta(hours=24)
    }
    
    return jsonify({
        'message': 'Login successful',
        'token': token,
        'user': {
            'user_id': user['user_id'],
            'username': user['username'],
            'email': user['email']
        }
    }), 200

@app.route('/api/profile', methods=['GET'])
@require_auth
def get_profile():
    """
    Get current authenticated user's profile
    Properly checks authorization - only returns current user's data
    """
    return jsonify({
        'user_id': g.current_user['user_id'],
        'username': g.current_user['username'],
        'email': g.current_user['email']
    }), 200

@app.route('/api/profile/update', methods=['PUT'])
@require_auth
def update_profile():
    """
    Update current authenticated user's profile
    Properly checks authorization - only updates current user's data
    """
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'No data provided'}), 400
    
    db = get_db()
    cursor = db.cursor()
    
    # Only allow updating email for current user
    if 'email' in data:
        cursor.execute(
            'UPDATE users SET email = ? WHERE user_id = ?',
            (data['email'], g.current_user['user_id'])
        )
        db.commit()
    
    return jsonify({'message': 'Profile updated successfully'}), 200

@app.route('/api/user/details', methods=['GET'])
@require_auth
def get_user_details():
    """
    Get user details by user_id
    
    VULNERABLE ENDPOINT - Missing authorization check!
    Accepts user_id as query parameter but doesn't verify if the authenticated
    user is authorized to access the requested user's data.
    
    Example: /api/user/details?user_id=1002
    """
    user_id = request.args.get('user_id')
    
    if not user_id:
        return jsonify({'error': 'Missing user_id parameter'}), 400
    
    try:
        user_id = int(user_id)
    except ValueError:
        return jsonify({'error': 'Invalid user_id format'}), 400
    
    db = get_db()
    cursor = db.cursor()
    
    # SECURITY FLAW: No check to verify g.current_user['user_id'] == user_id
    # This allows any authenticated user to query any other user's details
    cursor.execute(
        'SELECT user_id, username, email, created_at FROM users WHERE user_id = ?',
        (user_id,)
    )
    
    user = cursor.fetchone()
    
    if not user:
        return jsonify({'error': 'User not found'}), 404
    
    return jsonify({
        'user_id': user['user_id'],
        'username': user['username'],
        'email': user['email'],
        'created_at': user['created_at']
    }), 200

@app.route('/api/users/list', methods=['GET'])
@require_auth
def list_users():
    """
    List all usernames (public information only)
    Returns only usernames, not sensitive data like emails
    """
    db = get_db()
    cursor = db.cursor()
    
    cursor.execute('SELECT user_id, username FROM users')
    users = cursor.fetchall()
    
    return jsonify({
        'users': [{'user_id': user['user_id'], 'username': user['username']} for user in users]
    }), 200

@app.route('/api/logout', methods=['POST'])
@require_auth
def logout():
    """Logout endpoint - invalidates current token"""
    token = request.headers.get('Authorization')
    
    if token.startswith('Bearer '):
        token = token[7:]
    
    if token in active_tokens:
        del active_tokens[token]
    
    return jsonify({'message': 'Logged out successfully'}), 200

@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint - no authentication required"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat()
    }), 200

if __name__ == '__main__':
    # Initialize database with test data
    init_db()
    
    # Run Flask development server
    app.run(host='0.0.0.0', port=5000, debug=True)