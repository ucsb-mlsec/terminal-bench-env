#!/bin/bash

# First, let me examine what the original script is trying to do
# The original script at /workspace/scripts/search_config.sh needs to be analyzed

# Create the fixed search script
mkdir -p /solution

cat > /solution/search_config_fixed.sh << 'SCRIPT_END'
#!/bin/bash

# Fixed search script that safely handles binary files
# Purpose: Search for API endpoint configurations without corrupting terminal

SEARCH_DIR="/workspace/deploy_repo"
PATTERN="api.*endpoint|endpoint.*url|API_URL|BASE_URL"

# Initialize counters
binary_count=0
text_count=0
match_count=0

# Function to check if a file is binary
is_binary() {
    local file="$1"
    # Use grep -I or file command to detect binary
    if grep -qI . "$file" 2>/dev/null; then
        return 1  # It's text
    else
        return 0  # It's binary
    fi
}

# Find all files recursively
while IFS= read -r -d '' file; do
    # Skip directories
    if [ -d "$file" ]; then
        continue
    fi
    
    # Check if file is binary
    if is_binary "$file"; then
        ((binary_count++))
    else
        ((text_count++))
        # Safely search text files using grep with binary file suppression
        matches=$(grep -iE "$PATTERN" "$file" 2>/dev/null | wc -l)
        if [ "$matches" -gt 0 ]; then
            ((match_count += matches))
            echo "=== Found in: $file ==="
            grep -iE "$PATTERN" "$file" 2>/dev/null
            echo ""
        fi
    fi
done < <(find "$SEARCH_DIR" -type f -print0 2>/dev/null)

# Save report
cat > /solution/report.txt << REPORT
binary_files_found=$binary_count
text_files_searched=$text_count
matches_found=$match_count
REPORT

echo "Search complete. Summary:"
echo "Binary files found: $binary_count"
echo "Text files searched: $text_count"
echo "Total matches found: $match_count"
SCRIPT_END

chmod +x /solution/search_config_fixed.sh

# Now create the binary file content for data/deploy_repo/build/app.o
mkdir -p /workspace/deploy_repo/build

# Generate binary file with ELF header and mixed binary/text content
python3 << 'PYTHON_END'
import os
import struct
import random

output_file = '/workspace/deploy_repo/build/app.o'
os.makedirs(os.path.dirname(output_file), exist_ok=True)

with open(output_file, 'wb') as f:
    # ELF header signature
    f.write(bytes([0x7F, 0x45, 0x4C, 0x46]))  # .ELF
    
    # More ELF-like header bytes
    f.write(bytes([0x02, 0x01, 0x01, 0x00]))
    f.write(bytes([0x00] * 8))  # Padding
    f.write(bytes([0x01, 0x00, 0x3E, 0x00]))
    
    # Random binary data with control characters
    for _ in range(50):
        f.write(bytes([random.randint(0, 255)]))
    
    # Some null bytes (terminal killers)
    f.write(b'\x00\x00\x00\x00')
    
    # Escape sequences that corrupt terminals
    f.write(b'\x1B[0m\x1B[31m')
    
    # More random binary
    for _ in range(30):
        f.write(bytes([random.randint(0, 31)]))  # Control characters
    
    # Readable text string
    f.write(b'GCC: (GNU) 9.3.0\x00')
    
    # More binary garbage
    for _ in range(40):
        f.write(bytes([random.randint(0, 255)]))
    
    # Bell character and other problematic bytes
    f.write(b'\x07\x08\x09\x0A\x0B\x0C\x0D')
    
    # Another text string
    f.write(b'.text\x00.data\x00.bss\x00')
    
    # Random binary
    for _ in range(50):
        f.write(bytes([random.randint(0, 255)]))
    
    # Function name
    f.write(b'main\x00_start\x00')
    
    # More control characters and escape sequences
    f.write(b'\x1B[2J\x1B[H')  # Clear screen sequence
    
    # Random binary
    for _ in range(80):
        f.write(bytes([random.randint(0, 255)]))
    
    # Null bytes
    f.write(b'\x00\x00\x00\x00\x00\x00\x00\x00')
    
    # More compiler-like text
    f.write(b'__gmon_start__\x00printf\x00')
    
    # Final random binary block
    for _ in range(100):
        f.write(bytes([random.randint(0, 255)]))
    
    # More escape sequences
    f.write(b'\x1B[?25l\x1B[?25h')
    
    # Random bytes with high values
    for _ in range(50):
        f.write(bytes([random.randint(128, 255)]))
    
    # Terminal corruption sequences
    f.write(b'\x1B]0;')
    for _ in range(20):
        f.write(bytes([random.randint(0, 255)]))
    f.write(b'\x07')
    
    # Final padding
    for _ in range(50):
        f.write(bytes([random.randint(0, 255)]))

print(f"Created binary file: {output_file}")
print(f"File size: {os.path.getsize(output_file)} bytes")
PYTHON_END

# Create some sample text configuration files to search
mkdir -p /workspace/deploy_repo/config

cat > /workspace/deploy_repo/config/api.conf << 'EOF'
# API Configuration
api_endpoint=https://api.example.com/v1
BASE_URL=https://production.example.com
timeout=30
EOF

cat > /workspace/deploy_repo/config/settings.yaml << 'EOF'
service:
  name: deployment-service
  endpoint_url: https://deploy.example.com/api
  port: 8080
EOF

cat > /workspace/deploy_repo/config/endpoints.json << 'EOF'
{
  "api": {
    "primary_endpoint": "https://api.prod.example.com",
    "API_URL": "https://api.backup.example.com"
  }
}
EOF

# Run the fixed script
/solution/search_config_fixed.sh