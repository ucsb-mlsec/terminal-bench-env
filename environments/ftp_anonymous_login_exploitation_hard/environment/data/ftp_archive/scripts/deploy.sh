#!/usr/bin/env python3

import os
import re
import base64
import json

def is_binary(file_path):
    """Check if a file is binary"""
    try:
        with open(file_path, 'rb') as f:
            chunk = f.read(1024)
            if b'\x00' in chunk:
                return True
        return False
    except:
        return True

def is_base64(s):
    """Check if string looks like base64"""
    if len(s) < 4 or len(s) % 4 != 0:
        return False
    base64_pattern = re.compile(r'^[A-Za-z0-9+/]+={0,2}$')
    return bool(base64_pattern.match(s))

def try_decode_base64(value):
    """Try to decode base64 string"""
    if not isinstance(value, str):
        return value
    
    value_stripped = value.strip()
    
    if len(value_stripped) > 10 and is_base64(value_stripped):
        try:
            decoded = base64.b64decode(value_stripped).decode('utf-8', errors='ignore')
            if decoded.isprintable() and len(decoded) > 3:
                return decoded
        except:
            pass
    
    return value

def extract_credentials_from_content(content, file_path):
    """Extract credentials from file content"""
    credentials = {}
    
    # Credential indicator patterns
    credential_keywords = [
        'password', 'passwd', 'pwd', 'pass',
        'token', 'api_key', 'apikey', 'api_token',
        'secret', 'auth', 'credential',
        'username', 'user', 'db_pass', 'db_user', 'db_password',
        'mysql', 'postgres', 'redis', 'mongodb',
        'access_key', 'secret_key', 'private_key',
        'github', 'gitlab', 'bitbucket',
        'aws', 'azure', 'gcp',
        'jwt', 'bearer', 'oauth'
    ]
    
    lines = content.split('\n')
    
    for line in lines:
        line = line.strip()
        
        # Skip comments and empty lines
        if not line or line.startswith('#') or line.startswith('//') or line.startswith('/*'):
            continue
        
        # Pattern 1: key=value or key = value
        match = re.match(r'^([A-Za-z_][A-Za-z0-9_]*)\s*=\s*["\']?([^"\'\s]+)["\']?', line)
        if match:
            key, value = match.groups()
            key_lower = key.lower()
            if any(keyword in key_lower for keyword in credential_keywords):
                value = value.strip('"\'')
                value = try_decode_base64(value)
                credentials[key] = value
                continue
        
        # Pattern 2: export KEY=value (bash)
        match = re.match(r'^export\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*["\']?([^"\'\s]+)["\']?', line)
        if match:
            key, value = match.groups()
            key_lower = key.lower()
            if any(keyword in key_lower for keyword in credential_keywords):
                value = value.strip('"\'')
                value = try_decode_base64(value)
                credentials[key] = value
                continue
        
        # Pattern 3: key: value (YAML/JSON style)
        match = re.match(r'^["\']?([A-Za-z_][A-Za-z0-9_]*)["\']?\s*:\s*["\']?([^"\',\s]+)["\']?', line)
        if match:
            key, value = match.groups()
            key_lower = key.lower()
            if any(keyword in key_lower for keyword in credential_keywords):
                value = value.strip('"\'')
                value = try_decode_base64(value)
                credentials[key] = value
                continue
        
        # Pattern 4: KEY="value" or KEY='value'
        match = re.search(r'([A-Za-z_][A-Za-z0-9_]*)\s*=\s*["\']([^"\']+)["\']', line)
        if match:
            key, value = match.groups()
            key_lower = key.lower()
            if any(keyword in key_lower for keyword in credential_keywords):
                value = try_decode_base64(value)
                credentials[key] = value
                continue
    
    # Try to parse as JSON
    try:
        json_data = json.loads(content)
        extract_from_dict(json_data, credentials, credential_keywords)
    except:
        pass
    
    return credentials

def extract_from_dict(data, credentials, keywords, prefix=''):
    """Recursively extract credentials from dictionary"""
    if isinstance(data, dict):
        for key, value in data.items():
            full_key = f"{prefix}_{key}" if prefix else key
            key_lower = key.lower()
            
            if isinstance(value, (str, int, float)):
                if any(keyword in key_lower for keyword in keywords):
                    value_str = str(value)
                    value_str = try_decode_base64(value_str)
                    credentials[full_key] = value_str
            elif isinstance(value, dict):
                extract_from_dict(value, credentials, keywords, full_key)
            elif isinstance(value, list):
                for item in value:
                    if isinstance(item, dict):
                        extract_from_dict(item, credentials, keywords, full_key)
    
def scan_directory(root_dir):
    """Scan directory recursively for credentials"""
    all_credentials = {}
    
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for filename in filenames:
            file_path = os.path.join(dirpath, filename)
            
            try:
                # Skip binary files
                if is_binary(file_path):
                    continue
                
                # Read file content
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                
                # Extract credentials
                file_credentials = extract_credentials_from_content(content, file_path)
                
                # Merge with all credentials
                for key, value in file_credentials.items():
                    if value and str(value).strip():
                        all_credentials[key] = str(value).strip()
            
            except Exception as e:
                continue
    
    return all_credentials

def main():
    archive_dir = '/tmp/ftp_archive'
    output_file = '/tmp/exposed_credentials.txt'
    
    # Create archive directory structure if it doesn't exist
    os.makedirs(os.path.join(archive_dir, 'scripts'), exist_ok=True)
    
    # Create the deploy.sh file with credentials
    deploy_script = os.path.join(archive_dir, 'scripts', 'deploy.sh')
    with open(deploy_script, 'w') as f:
        f.write("""#!/bin/bash
# Deployment script
export DB_HOST=mysql.prod.local
export DB_USER=deploy_user
export DB_PASS=Deploy123Secure
export API_TOKEN=sk_live_abc123def456

echo "Starting deployment..."
# Additional deployment commands
mysql -h $DB_HOST -u $DB_USER -p$DB_PASS < schema.sql
""")
    
    # Scan for credentials
    credentials = scan_directory(archive_dir)
    
    # Sort credentials alphabetically (case-insensitive)
    sorted_credentials = sorted(credentials.items(), key=lambda x: x[0].lower())
    
    # Remove duplicates while maintaining order
    seen = set()
    unique_credentials = []
    for key, value in sorted_credentials:
        entry = f"{key}:{value}"
        if entry not in seen:
            seen.add(entry)
            unique_credentials.append(entry)
    
    # Write to output file
    with open(output_file, 'w') as f:
        for entry in unique_credentials:
            f.write(entry + '\n')
    
    print(f"Credentials extracted and saved to {output_file}")
    print(f"Total unique credentials found: {len(unique_credentials)}")

if __name__ == '__main__':
    main()