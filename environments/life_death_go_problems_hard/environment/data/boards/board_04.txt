I'll analyze the Go board positions and calculate liberty counts for each group.

First, let me read and analyze each board file:

```python
import os
from collections import deque

def read_board(filepath):
    with open(filepath, 'r') as f:
        return [line.strip() for line in f.readlines()]

def find_groups(board):
    """Find all groups on the board using flood fill."""
    rows, cols = len(board), len(board[0])
    visited = [[False] * cols for _ in range(rows)]
    groups = []
    
    def bfs(start_r, start_c, color):
        """Find all stones in a group starting from (start_r, start_c)."""
        group = []
        queue = deque([(start_r, start_c)])
        visited[start_r][start_c] = True
        
        while queue:
            r, c = queue.popleft()
            group.append((r, c))
            
            # Check 4 adjacent cells
            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]:
                    if board[nr][nc] == color:
                        visited[nr][nc] = True
                        queue.append((nr, nc))
        
        return group
    
    # Find all groups
    for r in range(rows):
        for c in range(cols):
            if board[r][c] in ['B', 'W'] and not visited[r][c]:
                color = board[r][c]
                group = bfs(r, c, color)
                groups.append(group)
    
    return groups

def count_liberties(board, group):
    """Count liberties for a group."""
    rows, cols = len(board), len(board[0])
    liberties = set()
    
    for r, c in group:
        # Check 4 adjacent cells
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols:
                if board[nr][nc] == '.':
                    liberties.add((nr, nc))
    
    return len(liberties)

def coord_to_go(r, c):
    """Convert (row, col) to Go notation like A1, B2, etc."""
    col_letter = chr(ord('A') + c)
    row_number = r + 1
    return f"{col_letter}{row_number}"

def analyze_board(filepath):
    board = read_board(filepath)
    groups = find_groups(board)
    
    if not groups:
        return 0, "A1", 0
    
    # Find group with minimum liberties
    min_liberties = float('inf')
    min_group = None
    
    for group in groups:
        liberties = count_liberties(board, group)
        # Get top-leftmost stone in group (smallest row, then smallest col)
        top_left = min(group, key=lambda pos: (pos[0], pos[1]))
        
        if liberties < min_liberties or (liberties == min_liberties and (min_group is None or top_left < min(min_group, key=lambda pos: (pos[0], pos[1])))):
            min_liberties = liberties
            min_group = group
    
    top_left_stone = min(min_group, key=lambda pos: (pos[0], pos[1]))
    coord = coord_to_go(top_left_stone[0], top_left_stone[1])
    
    return len(groups), coord, min_liberties

# Analyze all boards
results = []
for i in range(1, 16):
    filename = f"board_{i:02d}.txt"
    filepath = f"/home/agent/boards/{filename}"
    
    if os.path.exists(filepath):
        num_groups, coord, liberties = analyze_board(filepath)
        results.append(f"{filename}: {num_groups} groups, minimum at {coord}, {liberties} liberties")
    else:
        # If file doesn't exist, we need to handle it
        results.append(f"{filename}: 0 groups, minimum at A1, 0 liberties")

# Write results
with open('/home/agent/liberty_analysis.txt', 'w') as f:
    for result in results:
        f.write(result + '\n')