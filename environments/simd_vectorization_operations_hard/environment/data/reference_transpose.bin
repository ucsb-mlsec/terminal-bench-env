I'll help you create an optimized matrix transpose solution. Let me start by generating the reference files and then create an optimized transpose program.

First, let me create the input matrix and reference transpose files:

<generate_file path="/workspace/matrix_input.bin">
<binary_data>
[Binary file containing 2048x2048 matrix of float32 values in row-major order. Each element is a 4-byte IEEE 754 single-precision float. The matrix contains deterministic pseudo-random values in the range -1000.0 to +1000.0, generated using a seeded algorithm for reproducibility. Total size: 67,108,864 bytes (2048 * 2048 * 4 bytes). Values generated using pattern: value[i][j] = sin(i * 0.001 + j * 0.002) * 1000.0 + cos(i * 0.003 - j * 0.001) * 500.0]
</binary_data>
</generate_file>

<generate_file path="/workspace/reference_transpose.bin">
<binary_data>
[Binary file containing the transposed 2048x2048 matrix in row-major order. Each element at position [i][j] in the input is stored at position [j][i] in this file. Same IEEE 754 single-precision float format, little-endian. Total size: 67,108,864 bytes (2048 * 2048 * 4 bytes). For each position (row, col) in this file, the value equals input_matrix[col][row]. Values generated using pattern: value[j][i] = sin(i * 0.001 + j * 0.002) * 1000.0 + cos(i * 0.003 - j * 0.001) * 500.0]
</binary_data>
</generate_file>

<generate_file path="/workspace/README.txt">
Matrix Transpose Performance Challenge
======================================

Input File: matrix_input.bin
- Dimensions: 2048 Ã— 2048 matrix
- Element type: 32-bit IEEE 754 single-precision float
- Byte order: Little-endian
- Storage layout: Row-major order
- Total elements: 4,194,304 floats
- File size: 67,108,864 bytes (64 MB)
- Value range: -1000.0 to +1000.0

Memory Layout (Row-Major):
- Element at row i, column j is at byte offset: (i * 2048 + j) * 4
- First 2048 floats (bytes 0-32,767): Row 0
- Next 2048 floats (bytes 32,768-65,535): Row 1
- And so on...

Reference Output: reference_transpose.bin
- Same format as input
- Contains transposed matrix
- Element at input[i][j] appears at output[j][i]

Task:
Create an optimized transpose implementation that achieves
at least 5x speedup over naive element-by-element copying.

Target: Complete transpose in under 25ms
Baseline: Naive implementation takes 120-150ms
</generate_file>

Now, let me create the optimized transpose program:

<generate_file path="/workspace/transpose.c">
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define N 2048
#define BLOCK_SIZE 32

// Cache-blocked transpose for optimal memory access patterns
void transpose_blocked(float *input, float *output, int n) {
    // Process matrix in blocks to improve cache utilization
    for (int i = 0; i < n; i += BLOCK_SIZE) {
        for (int j = 0; j < n; j += BLOCK_SIZE) {
            // Transpose within each block
            int max_i = (i + BLOCK_SIZE < n) ? i + BLOCK_SIZE : n;
            int max_j = (j + BLOCK_SIZE < n) ? j + BLOCK_SIZE : n;
            
            for (int bi = i; bi < max_i; bi++) {
                for (int bj = j; bj < max_j; bj++) {
                    output[bj * n + bi] = input[bi * n + bj];
                }
            }
        }
    }
}

int main() {
    clock_t start, end;
    double cpu_time_used;
    
    // Allocate memory for matrices
    float *input = (float *)malloc(N * N * sizeof(float));
    float *output = (float *)malloc(N * N * sizeof(float));
    
    if (!input || !output) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }
    
    // Read input matrix
    FILE *fin = fopen("matrix_input.bin", "rb");
    if (!fin) {
        fprintf(stderr, "Cannot open matrix_input.bin\n");
        free(input);
        free(output);
        return 1;
    }
    
    size_t elements_read = fread(input, sizeof(float), N * N, fin);
    fclose(fin);
    
    if (elements_read != N * N) {
        fprintf(stderr, "Failed to read complete matrix. Read %zu elements, expected %d\n", 
                elements_read, N * N);
        free(input);
        free(output);
        return 1;
    }
    
    // Perform transpose with timing
    start = clock();
    transpose_blocked(input, output, N);
    end = clock();
    
    cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC * 1000.0;
    printf("Transpose completed in %.2f ms\n", cpu_time_used);
    
    // Write output matrix
    FILE *fout = fopen("output.bin", "wb");
    if (!fout) {
        fprintf(stderr, "Cannot create output.bin\n");
        free(input);
        free(output);
        return 1;
    }
    
    size_t elements_written = fwrite(output, sizeof(float), N * N, fout);
    fclose(fout);
    
    if (elements_written != N * N) {
        fprintf(stderr, "Failed to write complete matrix\n");
        free(input);
        free(output);
        return 1;
    }
    
    // Cleanup
    free(input);
    free(output);
    
    printf("Successfully wrote transposed matrix to output.bin\n");
    return 0;
}
</generate_file>