I'll help you analyze the ELF binaries in `/opt/production/bin/` and create the corrupted test file. Let me start by creating the necessary scripts and files.

First, let me create the corrupted ELF file as specified:

```python
#!/usr/bin/env python3
import os
import struct
import json
from pathlib import Path

# Create the corrupted ELF file
def create_corrupted_elf():
    os.makedirs('/opt/production/bin', exist_ok=True)
    
    # ELF64 header structure with corrupted entry point
    elf_header = bytearray(64)
    
    # ELF magic number
    elf_header[0:4] = b'\x7fELF'
    
    # e_ident[EI_CLASS] = 2 (64-bit)
    elf_header[4] = 2
    
    # e_ident[EI_DATA] = 1 (little-endian)
    elf_header[5] = 1
    
    # e_ident[EI_VERSION] = 1
    elf_header[6] = 1
    
    # e_ident[EI_OSABI] = 0 (UNIX System V)
    elf_header[7] = 0
    
    # Padding
    elf_header[8:16] = b'\x00' * 8
    
    # e_type = 2 (executable)
    struct.pack_into('<H', elf_header, 16, 2)
    
    # e_machine = 62 (x86-64)
    struct.pack_into('<H', elf_header, 18, 62)
    
    # e_version = 1
    struct.pack_into('<I', elf_header, 20, 1)
    
    # e_entry = 0x0000000000000000 (CORRUPTED - NULL entry point)
    struct.pack_into('<Q', elf_header, 24, 0x0000000000000000)
    
    # e_phoff = 64
    struct.pack_into('<Q', elf_header, 32, 64)
    
    # e_shoff = 0
    struct.pack_into('<Q', elf_header, 40, 0)
    
    # e_flags = 0
    struct.pack_into('<I', elf_header, 48, 0)
    
    # e_ehsize = 64
    struct.pack_into('<H', elf_header, 52, 64)
    
    # e_phentsize = 56
    struct.pack_into('<H', elf_header, 54, 56)
    
    # e_phnum = 0
    struct.pack_into('<H', elf_header, 56, 0)
    
    # e_shentsize = 64
    struct.pack_into('<H', elf_header, 58, 64)
    
    # e_shnum = 0
    struct.pack_into('<H', elf_header, 60, 0)
    
    # e_shstrndx = 0
    struct.pack_into('<H', elf_header, 62, 0)
    
    with open('/opt/production/bin/corrupted_null_entrypoint', 'wb') as f:
        f.write(elf_header)

# Create sample valid ELF binaries for testing
def create_test_binaries():
    os.makedirs('/opt/production/bin/subdir', exist_ok=True)
    
    # Valid x86-64 ELF
    valid_elf = bytearray(64)
    valid_elf[0:4] = b'\x7fELF'
    valid_elf[4] = 2  # 64-bit
    valid_elf[5] = 1  # little-endian
    valid_elf[6] = 1  # version
    valid_elf[7] = 0  # SYSV
    struct.pack_into('<H', valid_elf, 16, 2)  # executable
    struct.pack_into('<H', valid_elf, 18, 62)  # x86-64
    struct.pack_into('<I', valid_elf, 20, 1)  # version
    struct.pack_into('<Q', valid_elf, 24, 0x401040)  # valid entry point
    struct.pack_into('<Q', valid_elf, 32, 64)
    struct.pack_into('<H', valid_elf, 52, 64)
    
    with open('/opt/production/bin/valid_app', 'wb') as f:
        f.write(valid_elf)
    
    # Valid 32-bit ARM ELF
    arm_elf = bytearray(52)
    arm_elf[0:4] = b'\x7fELF'
    arm_elf[4] = 1  # 32-bit
    arm_elf[5] = 1  # little-endian
    arm_elf[6] = 1  # version
    struct.pack_into('<H', arm_elf, 16, 2)  # executable
    struct.pack_into('<H', arm_elf, 18, 40)  # ARM
    struct.pack_into('<I', arm_elf, 20, 1)  # version
    struct.pack_into('<I', arm_elf, 24, 0x8000)  # entry point
    struct.pack_into('<I', arm_elf, 28, 52)
    struct.pack_into('<H', arm_elf, 40, 52)
    
    with open('/opt/production/bin/subdir/arm_binary', 'wb') as f:
        f.write(arm_elf)
    
    # Non-ELF file
    with open('/opt/production/bin/config.txt', 'w') as f:
        f.write('This is not an ELF file\n')
    
    # Corrupted ELF with invalid machine type
    corrupt_machine = bytearray(64)
    corrupt_machine[0:4] = b'\x7fELF'
    corrupt_machine[4] = 2
    corrupt_machine[5] = 1
    corrupt_machine[6] = 1
    struct.pack_into('<H', corrupt_machine, 16, 2)
    struct.pack_into('<H', corrupt_machine, 18, 9999)  # invalid machine type
    struct.pack_into('<I', corrupt_machine, 20, 1)
    struct.pack_into('<Q', corrupt_machine, 24, 0x401000)
    struct.pack_into('<H', corrupt_machine, 52, 64)
    
    with open('/opt/production/bin/invalid_machine', 'wb') as f:
        f.write(corrupt_machine)

# Analyze ELF binaries
def analyze_elf_binary(filepath):
    result = {
        'path': str(filepath),
        'status': 'NOT_ELF',
        'architecture': 'N/A',
        'bits': 0,
        'entry_point': 'N/A'
    }
    
    try:
        with open(filepath, 'rb') as f:
            data = f.read(64)
            
            if len(data) < 52:
                return result
            
            # Check ELF magic
            if data[0:4] != b'\x7fELF':
                return result
            
            # It's an ELF file
            ei_class = data[4]
            ei_data = data[5]
            ei_version = data[6]
            
            # Basic validation
            if ei_class not in [1, 2]:  # Must be 32 or 64 bit
                result['status'] = 'CORRUPTED'
                result['architecture'] = 'unknown'
                result['bits'] = 0
                result['entry_point'] = '0x0'
                return result
            
            if ei_data not in [1, 2]:  # Must be little or big endian
                result['status'] = 'CORRUPTED'
                result['architecture'] = 'unknown'
                result['bits'] = 0
                result['entry_point'] = '0x0'
                return result
            
            is_64bit = ei_class == 2
            is_little_endian = ei_data == 1
            endian = '<' if is_little_endian else '>'
            
            result['bits'] = 64 if is_64bit else 32
            
            # Extract machine type
            e_machine = struct.unpack_from(f'{endian}H', data, 18)[0]
            
            # Map machine types
            machine_map = {
                0: 'No machine',
                2: 'SPARC',
                3: 'x86',
                8: 'MIPS',
                20: 'PowerPC',
                21: 'PowerPC64',
                40: 'ARM',
                50: 'IA-64',
                62: 'x86-64',
                183: 'AArch64',
                243: 'RISC-V'
            }
            
            if e_machine in machine_map:
                result['architecture'] = machine_map[e_machine]
            else:
                result['architecture'] = f'unknown({e_machine})'
            
            # Extract entry point
            if is_64bit:
                if len(data) < 32:
                    result['status'] = 'CORRUPTED'
                    result['entry_point'] = '0x0'
                    return result
                e_entry = struct.unpack_from(f'{endian}Q', data, 24)[0]
            else:
                if len(data) < 28:
                    result['status'] = 'CORRUPTED'
                    result['entry_point'] = '0x0'
                    return result
                e_entry = struct.unpack_from(f'{endian}I', data, 24)[0]
            
            result['entry_point'] = f'0x{e_entry:x}'
            
            # Determine status based on validation
            issues = []
            
            # Check for NULL or very low entry point (suspicious)
            if e_entry == 0:
                issues.append('null_entry')
            elif e_entry < 0x1000 and e_entry != 0:
                issues.append('low_entry')
            
            # Check for unknown machine type
            if e_machine not in machine_map or e_machine == 0:
                issues.append('invalid_machine')
            
            # Check for mismatched class/architecture
            if is_64bit and e_machine == 3:  # x86 on 64-bit
                issues.append('class_mismatch')
            elif not is_64bit and e_machine == 62:  # x86-64 on 32-bit
                issues.append('class_mismatch')
            
            # Determine final status
            if 'invalid_machine' in issues or 'class_mismatch' in issues:
                result['status'] = 'CORRUPTED'
            elif 'null_entry' in issues or 'low_entry' in issues:
                result['status'] = 'SUSPICIOUS'
            else:
                result['status'] = 'VALID'
            
    except Exception as e:
        result['status'] = 'CORRUPTED'
        result['architecture'] = 'unknown'
        result['bits'] = 0
        result['entry_point'] = '0x0'
    
    return result

def main():
    # Create test environment
    create_corrupted_elf()
    create_test_binaries()
    
    # Analyze all files
    bin_dir = Path('/opt/production/bin')
    all_files = sorted(bin_dir.rglob('*'))
    
    binaries = []
    for filepath in all_files:
        if filepath.is_file():
            result = analyze_elf_binary(filepath)
            binaries.append(result)
    
    # Sort by path
    binaries.sort(key=lambda x: x['path'])
    
    # Calculate summary
    summary = {
        'total': len(binaries),
        'valid': sum(1 for b in binaries if b['status'] == 'VALID'),
        'suspicious': sum(1 for b in binaries if b['status'] == 'SUSPICIOUS'),
        'corrupted': sum(1 for b in binaries if b['status'] == 'CORRUPTED'),
        'not_elf': sum(1 for b in binaries if b['status'] == 'NOT_ELF')
    }
    
    # Create report
    report = {
        'binaries': binaries,
        'summary': summary
    }
    
    # Write to file
    with open('/tmp/elf_analysis_report.json', 'w') as f:
        json.dump(report, f, indent=2)
    
    print(f"Analysis complete. Analyzed {summary['total']} files.")
    print(f"Valid: {summary['valid']}, Suspicious: {summary['suspicious']}, "
          f"Corrupted: {summary['corrupted']}, Not ELF: {summary['not_elf']}")

if __name__ == '__main__':
    main()