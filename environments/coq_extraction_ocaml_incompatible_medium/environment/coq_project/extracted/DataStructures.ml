(** val insert : int -> tree -> tree **)
(** val search : int -> tree -> bool **)
(** val size : tree -> nat **)
(** val height : tree -> nat **)

(* Generated by coqc extraction *)

type nat =
| O
| S of nat

type tree =
| Leaf
| Node of int * tree * tree

(** val add_nat : nat -> nat -> nat **)

let rec add_nat n m =
  match n with
  | O -> m
  | S p -> S (add_nat p m)

(** val max_nat : nat -> nat -> nat **)

let rec max_nat n m =
  match n with
  | O -> m
  | S n' ->
    (match m with
     | O -> n
     | S m' -> S (max_nat n' m'))

(** val nat_to_int : nat -> int **)

let rec nat_to_int n =
  match n with
  | O -> 0
  | S n' -> 1 + (nat_to_int n')

(** val int_to_nat : int -> nat **)

let rec int_to_nat n =
  if n <= 0 then O else S (int_to_nat (n - 1))

(** val insert : int -> tree -> tree **)

let rec insert x t =
  match t with
  | Leaf -> Node (x, Leaf, Leaf)
  | Node (y, l, r) ->
    if x < y then Node (y, (insert x l), r)
    else if x > y then Node (y, l, (insert x r))
    else t

(** val search : int -> tree -> bool **)

let rec search x t =
  match t with
  | Leaf -> false
  | Node (y, l, r) ->
    if x < y then search x l
    else if x > y then search x r
    else true

(** val size : tree -> nat **)

let rec size t =
  match t with
  | Leaf -> O
  | Node (_, l, r) -> S (add_nat (size l) (size r))

(** val height : tree -> nat **)

let rec height t =
  match t with
  | Leaf -> O
  | Node (_, l, r) -> S (max_nat (height l) (height r))

(** val is_empty : tree -> bool **)

let is_empty t =
  match t with
  | Leaf -> true
  | Node (_, _, _) -> false

(** val get_size_int : tree -> int **)

let get_size_int t =
  nat_to_int (size t)

(** val get_height_int : tree -> int **)

let get_height_int t =
  nat_to_int (height t)

(** val count_nodes : tree -> nat **)

let rec count_nodes t =
  match t with
  | Leaf -> 0
  | Node (_, l, r) -> 1 + (add_nat (count_nodes l) (count_nodes r))

(** val depth_of : int -> tree -> nat **)

let rec depth_of x t =
  match t with
  | Leaf -> O
  | Node (y, l, r) ->
    if x < y then S (depth_of x l)
    else if x > y then S (depth_of x r)
    else O

(** val min_element : tree -> int option **)

let rec min_element t =
  match t with
  | Leaf -> None
  | Node (x, Leaf, _) -> Some x
  | Node (_, l, _) -> min_element l

(** val max_element : tree -> int option **)

let rec max_element t =
  match t with
  | Leaf -> None
  | Node (x, _, Leaf) -> Some x
  | Node (_, _, r) -> max_element r

(** val compare_sizes : tree -> tree -> int **)

let compare_sizes t1 t2 =
  let s1 = size t1 in
  let s2 = size t2 in
  (nat_to_int s1) - (nat_to_int s2)

(** val sum_heights : tree -> tree -> nat **)

let sum_heights t1 t2 =
  add_nat (height t1) (height t2)

(** val total_depth : int -> tree -> int **)

let total_depth x t =
  let d = depth_of x t in
  nat_to_int d

(** val nodes_at_depth : nat -> tree -> int **)

let rec nodes_at_depth d t =
  match d with
  | O ->
    (match t with
     | Leaf -> O
     | Node (_, _, _) -> S O)
  | S d' ->
    (match t with
     | Leaf -> O
     | Node (_, l, r) -> add_nat (nodes_at_depth d' l) (nodes_at_depth d' r))

(** val balanced_factor : tree -> int **)

let balanced_factor t =
  match t with
  | Leaf -> 0
  | Node (_, l, r) ->
    let hl = height l in
    let hr = height r in
    (nat_to_int hl) - (nat_to_int hr)

(** val verify_height_property : tree -> nat -> bool **)

let rec verify_height_property t expected =
  match t with
  | Leaf -> 
    (match expected with
     | O -> true
     | S _ -> false)
  | Node (_, l, r) ->
    let h = height t in
    h = expected