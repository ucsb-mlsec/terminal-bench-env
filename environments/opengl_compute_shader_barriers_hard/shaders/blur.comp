#version 430

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform readonly image2D inputImage;
layout(binding = 1, rgba8) uniform writeonly image2D outputImage;

shared vec4 sharedData[18][18];

void main() {
    ivec2 globalID = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localID = ivec2(gl_LocalInvocationID.xy);
    ivec2 imageSize = imageSize(inputImage);
    
    // Bounds check
    if (globalID.x >= imageSize.x || globalID.y >= imageSize.y) {
        return;
    }
    
    // Load data into shared memory with 1-pixel border
    ivec2 sharedCoord = localID + ivec2(1, 1);
    ivec2 loadCoord = globalID;
    sharedData[sharedCoord.y][sharedCoord.x] = imageLoad(inputImage, loadCoord);
    
    // MISSING: barrier() should be here at line 23
    
    // Load border pixels for threads at edges
    if (localID.x == 0) {
        sharedData[sharedCoord.y][0] = imageLoad(inputImage, loadCoord - ivec2(1, 0));
    }
    if (localID.x == 15) {
        sharedData[sharedCoord.y][17] = imageLoad(inputImage, loadCoord + ivec2(1, 0));
    }
    if (localID.y == 0) {
        sharedData[0][sharedCoord.x] = imageLoad(inputImage, loadCoord - ivec2(0, 1));
    }
    if (localID.y == 15) {
        sharedData[17][sharedCoord.x] = imageLoad(inputImage, loadCoord + ivec2(0, 1));
    }
    
    // Perform blur computation using shared memory
    vec4 result = vec4(0.0);
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            result += sharedData[sharedCoord.y + y][sharedCoord.x + x];
        }
    }
    result /= 9.0;
    
    // Write blurred result to output image
    imageStore(outputImage, globalID, result);
    
    // MISSING: memoryBarrierImage() should be here at line 45
    
    // Additional processing that depends on the written output
    vec4 feedback = imageLoad(outputImage, globalID);
    vec4 enhanced = mix(result, feedback, 0.5);
    imageStore(outputImage, globalID, enhanced);
}