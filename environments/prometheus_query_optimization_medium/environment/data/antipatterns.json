[
  {
    "pattern_id":"unnecessary_rate_irate",
    "description":"Using rate() on a counter that is already wrapped in irate() or vice versa. Double rate calculations are redundant and cause performance issues.",
    "example":"rate(irate(http_requests_total[5m])[10m:])"
  },
  {
    "pattern_id":"excessive_time_range",
    "description":"Using extremely large time ranges (>1h) in rate\/increase functions when shorter ranges would suffice. This causes unnecessary data scanning.",
    "example":"rate(http_requests_total[6h])"
  },
  {
    "pattern_id":"inefficient_regex",
    "description":"Using regex matching with .* or .+ patterns that could be replaced with exact matching or more specific patterns. Regex is computationally expensive.",
    "example":"{__name__=~\".*_total\"}"
  },
  {
    "pattern_id":"absent_misuse",
    "description":"Using absent() function in ways that don't actually check for missing metrics correctly or using it when a simple comparison would work better.",
    "example":"absent(up == 1)"
  },
  {
    "pattern_id":"nested_subqueries",
    "description":"Using nested subqueries or multiple layers of aggregation that could be simplified into a single query operation.",
    "example":"sum(rate(sum(http_requests_total)[5m:1m]))"
  },
  {
    "pattern_id":"unanchored_regex",
    "description":"Using regex patterns without anchors (^ or $) causing full string scanning instead of prefix\/suffix matching.",
    "example":"{endpoint=~\"api\"}"
  }
]