I'll help you generate the BSON file content. Since BSON is a binary format, I'll provide the Python code that generates the actual binary BSON file with the specifications you mentioned.

```python
import bson
import os
from datetime import datetime, timedelta
from bson import ObjectId
import struct

# Create directory if it doesn't exist
os.makedirs('/data/mongodb_exports/', exist_ok=True)

# Generate valid customer records
customers = []

# Generate 75 valid customer records
for i in range(1, 76):
    customer = {
        '_id': ObjectId(),
        'name': f'Customer {i}',
        'email': f'customer{i}@example.com',
        'registration_date': datetime(2023, 1, 1) + timedelta(days=i*3),
        'status': 'active' if i % 5 != 0 else 'inactive',
        'address': {
            'street': f'{100 + i} Main Street',
            'city': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'][i % 5],
            'state': ['NY', 'CA', 'IL', 'TX', 'AZ'][i % 5],
            'zip': f'{10000 + i:05d}'
        }
    }
    customers.append(customer)

# Write valid records to BSON file
with open('/data/mongodb_exports/customers.bson', 'wb') as f:
    for customer in customers:
        # Encode each document
        doc_bytes = bson.encode(customer)
        f.write(doc_bytes)
    
    # Add corrupted record 1: Truncated BSON document
    valid_doc = bson.encode({
        '_id': ObjectId(),
        'name': 'Corrupted Customer 1',
        'email': 'corrupted1@example.com'
    })
    # Write only partial document (truncate it)
    f.write(valid_doc[:len(valid_doc)//2])
    
    # Add corrupted record 2: Invalid length prefix
    corrupted_bytes = struct.pack('<i', 999999)  # Impossibly large length
    corrupted_bytes += b'\x02name\x00\x06\x00\x00\x00Bad\x00'
    f.write(corrupted_bytes)
    
    # Add corrupted record 3: Malformed BSON with invalid type marker
    corrupted_bytes = struct.pack('<i', 25)  # Length
    corrupted_bytes += b'\xFF'  # Invalid BSON type
    corrupted_bytes += b'invalid_field\x00'
    corrupted_bytes += b'\x00' * 10
    f.write(corrupted_bytes)

print("customers.bson created with 75 valid records and 3 corrupted records")
```

However, since I need to output the actual binary file content directly, let me generate it properly:

import bson
import struct
from datetime import datetime, timedelta
from bson import ObjectId
import sys

output = b''

# Generate 75 valid customer records
for i in range(1, 76):
    customer = {
        '_id': ObjectId(),
        'name': f'Customer {i}',
        'email': f'customer{i}@example.com',
        'registration_date': datetime(2023, 1, 1) + timedelta(days=i*3),
        'status': 'active' if i % 5 != 0 else 'inactive',
        'address': {
            'street': f'{100 + i} Main Street',
            'city': ['New York', 'Los Angeles', 'Chicago', 'Houston', 'Phoenix'][i % 5],
            'state': ['NY', 'CA', 'IL', 'TX', 'AZ'][i % 5],
            'zip': f'{10000 + i:05d}'
        }
    }
    output += bson.encode(customer)

# Add corrupted record 1: Truncated BSON
valid_doc = bson.encode({'_id': ObjectId(), 'name': 'Corrupted1', 'email': 'c1@test.com'})
output += valid_doc[:len(valid_doc)//2]

# Add corrupted record 2: Invalid length
output += struct.pack('<i', 999999) + b'\x02name\x00\x06\x00\x00\x00Bad\x00'

# Add corrupted record 3: Invalid type marker
output += struct.pack('<i', 25) + b'\xFF' + b'field\x00' + b'\x00' * 18

sys.stdout.buffer.write(output)