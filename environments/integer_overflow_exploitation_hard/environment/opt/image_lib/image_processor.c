#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#define MAX_IMAGE_DIMENSION 16384
#define BYTES_PER_PIXEL 4
#define IMAGE_FORMAT_RGBA 1
#define IMAGE_FORMAT_RGB 2
#define IMAGE_FORMAT_GRAYSCALE 3

// Image structure to hold image data and metadata
typedef struct {
    unsigned int width;
    unsigned int height;
    unsigned int format;
    unsigned char *data;
    size_t data_size;
} Image;

// Function prototypes
Image* create_image(unsigned int width, unsigned int height, unsigned int format);
int validate_dimensions(unsigned int width, unsigned int height);
void destroy_image(Image *img);
int apply_brightness_filter(Image *img, int brightness_delta);
int apply_contrast_filter(Image *img, float contrast_factor);
int resize_image(Image *img, unsigned int new_width, unsigned int new_height);
Image* clone_image(Image *src);
int save_image_metadata(Image *img, const char *filename);

// Helper function to validate image dimensions
int validate_dimensions(unsigned int width, unsigned int height) {
    if (width == 0 || height == 0) {
        fprintf(stderr, "Error: Image dimensions cannot be zero\n");
        return 0;
    }
    if (width > MAX_IMAGE_DIMENSION || height > MAX_IMAGE_DIMENSION) {
        fprintf(stderr, "Warning: Image dimensions exceed recommended maximum\n");
    }
    return 1;
}

// Initialize a new image structure
Image* create_image(unsigned int width, unsigned int height, unsigned int format) {
    if (!validate_dimensions(width, height)) {
        return NULL;
    }

    Image *img = (Image*)malloc(sizeof(Image));
    if (!img) {
        fprintf(stderr, "Error: Failed to allocate memory for image structure\n");
        return NULL;
    }

    img->width = width;
    img->height = height;
    img->format = format;
    img->data = NULL;
    img->data_size = 0;

    return img;
}

// Allocate buffer for image data
int allocate_image_buffer(Image *img) {
    if (!img) {
        fprintf(stderr, "Error: NULL image pointer\n");
        return 0;
    }

    unsigned int bytes_per_pixel;
    switch (img->format) {
        case IMAGE_FORMAT_RGBA:
            bytes_per_pixel = 4;
            break;
        case IMAGE_FORMAT_RGB:
            bytes_per_pixel = 3;
            break;
        case IMAGE_FORMAT_GRAYSCALE:
            bytes_per_pixel = 1;
            break;
        default:
            fprintf(stderr, "Error: Unknown image format\n");
            return 0;
    }

    size_t buffer_size = img->width * img->height * bytes_per_pixel;
    
    img->data = (unsigned char*)malloc(buffer_size);
    if (!img->data) {
        fprintf(stderr, "Error: Failed to allocate image buffer\n");
        return 0;
    }

    img->data_size = buffer_size;
    memset(img->data, 0, buffer_size);
    
    return 1;
}

// Free image resources
void destroy_image(Image *img) {
    if (img) {
        if (img->data) {
            free(img->data);
            img->data = NULL;
        }
        free(img);
    }
}

// Apply brightness adjustment to image
int apply_brightness_filter(Image *img, int brightness_delta) {
    if (!img || !img->data) {
        fprintf(stderr, "Error: Invalid image for brightness filter\n");
        return 0;
    }

    unsigned int total_pixels = img->width * img->height;
    unsigned int bytes_per_pixel = (img->format == IMAGE_FORMAT_RGBA) ? 4 : 
                                   (img->format == IMAGE_FORMAT_RGB) ? 3 : 1;

    for (unsigned int i = 0; i < total_pixels * bytes_per_pixel; i++) {
        int new_value = img->data[i] + brightness_delta;
        if (new_value > 255) new_value = 255;
        if (new_value < 0) new_value = 0;
        img->data[i] = (unsigned char)new_value;
    }

    return 1;
}

// Apply contrast adjustment to image
int apply_contrast_filter(Image *img, float contrast_factor) {
    if (!img || !img->data) {
        fprintf(stderr, "Error: Invalid image for contrast filter\n");
        return 0;
    }

    if (contrast_factor < 0.0f) {
        fprintf(stderr, "Error: Contrast factor must be non-negative\n");
        return 0;
    }

    unsigned int total_pixels = img->width * img->height;
    unsigned int bytes_per_pixel = (img->format == IMAGE_FORMAT_RGBA) ? 4 : 
                                   (img->format == IMAGE_FORMAT_RGB) ? 3 : 1;

    for (unsigned int i = 0; i < total_pixels * bytes_per_pixel; i++) {
        float normalized = (img->data[i] - 128.0f) * contrast_factor + 128.0f;
        if (normalized > 255.0f) normalized = 255.0f;
        if (normalized < 0.0f) normalized = 0.0f;
        img->data[i] = (unsigned char)normalized;
    }

    return 1;
}

// Clone an existing image
Image* clone_image(Image *src) {
    if (!src) {
        fprintf(stderr, "Error: Cannot clone NULL image\n");
        return NULL;
    }

    Image *clone = create_image(src->width, src->height, src->format);
    if (!clone) {
        return NULL;
    }

    if (!allocate_image_buffer(clone)) {
        destroy_image(clone);
        return NULL;
    }

    memcpy(clone->data, src->data, src->data_size);
    return clone;
}

// Resize image to new dimensions
int resize_image(Image *img, unsigned int new_width, unsigned int new_height) {
    if (!img) {
        fprintf(stderr, "Error: NULL image pointer\n");
        return 0;
    }

    if (!validate_dimensions(new_width, new_height)) {
        return 0;
    }

    unsigned char *old_data = img->data;
    size_t old_size = img->data_size;
    unsigned int old_width = img->width;
    unsigned int old_height = img->height;

    img->width = new_width;
    img->height = new_height;
    img->data = NULL;
    img->data_size = 0;

    if (!allocate_image_buffer(img)) {
        img->width = old_width;
        img->height = old_height;
        img->data = old_data;
        img->data_size = old_size;
        return 0;
    }

    // Simple nearest-neighbor resampling
    unsigned int bytes_per_pixel = (img->format == IMAGE_FORMAT_RGBA) ? 4 : 
                                   (img->format == IMAGE_FORMAT_RGB) ? 3 : 1;

    for (unsigned int y = 0; y < new_height; y++) {
        for (unsigned int x = 0; x < new_width; x++) {
            unsigned int src_x = (x * old_width) / new_width;
            unsigned int src_y = (y * old_height) / new_height;
            
            unsigned int src_offset = (src_y * old_width + src_x) * bytes_per_pixel;
            unsigned int dst_offset = (y * new_width + x) * bytes_per_pixel;

            for (unsigned int b = 0; b < bytes_per_pixel; b++) {
                img->data[dst_offset + b] = old_data[src_offset + b];
            }
        }
    }

    free(old_data);
    return 1;
}

// Apply a simple box blur filter
int apply_blur_filter(Image *img, unsigned int radius) {
    if (!img || !img->data) {
        fprintf(stderr, "Error: Invalid image for blur filter\n");
        return 0;
    }

    if (radius == 0 || radius > 50) {
        fprintf(stderr, "Error: Invalid blur radius\n");
        return 0;
    }

    Image *temp = clone_image(img);
    if (!temp) {
        return 0;
    }

    unsigned int bytes_per_pixel = (img->format == IMAGE_FORMAT_RGBA) ? 4 : 
                                   (img->format == IMAGE_FORMAT_RGB) ? 3 : 1;

    for (unsigned int y = 0; y < img->height; y++) {
        for (unsigned int x = 0; x < img->width; x++) {
            unsigned int sum[4] = {0, 0, 0, 0};
            unsigned int count = 0;

            for (int dy = -(int)radius; dy <= (int)radius; dy++) {
                for (int dx = -(int)radius; dx <= (int)radius; dx++) {
                    int nx = (int)x + dx;
                    int ny = (int)y + dy;

                    if (nx >= 0 && nx < (int)img->width && ny >= 0 && ny < (int)img->height) {
                        unsigned int offset = (ny * img->width + nx) * bytes_per_pixel;
                        for (unsigned int b = 0; b < bytes_per_pixel; b++) {
                            sum[b] += temp->data[offset + b];
                        }
                        count++;
                    }
                }
            }

            unsigned int dst_offset = (y * img->width + x) * bytes_per_pixel;
            for (unsigned int b = 0; b < bytes_per_pixel; b++) {
                img->data[dst_offset + b] = (unsigned char)(sum[b] / count);
            }
        }
    }

    destroy_image(temp);
    return 1;
}

// Save image metadata to a file
int save_image_metadata(Image *img, const char *filename) {
    if (!img || !filename) {
        fprintf(stderr, "Error: Invalid parameters for saving metadata\n");
        return 0;
    }

    FILE *fp = fopen(filename, "w");
    if (!fp) {
        fprintf(stderr, "Error: Could not open file for writing\n");
        return 0;
    }

    fprintf(fp, "Image Metadata:\n");
    fprintf(fp, "Width: %u\n", img->width);
    fprintf(fp, "Height: %u\n", img->height);
    fprintf(fp, "Format: %u\n", img->format);
    fprintf(fp, "Data Size: %zu bytes\n", img->data_size);

    fclose(fp);
    return 1;
}

// Load raw image data from file
int load_raw_image_data(Image *img, const char *filename) {
    if (!img || !filename) {
        fprintf(stderr, "Error: Invalid parameters for loading image\n");
        return 0;
    }

    FILE *fp = fopen(filename, "rb");
    if (!fp) {
        fprintf(stderr, "Error: Could not open image file\n");
        return 0;
    }

    if (!allocate_image_buffer(img)) {
        fclose(fp);
        return 0;
    }

    size_t bytes_read = fread(img->data, 1, img->data_size, fp);
    fclose(fp);

    if (bytes_read != img->data_size) {
        fprintf(stderr, "Warning: Read %zu bytes, expected %zu bytes\n", 
                bytes_read, img->data_size);
    }

    return 1;
}

// Calculate histogram for image analysis
int calculate_histogram(Image *img, unsigned int *histogram, unsigned int histogram_size) {
    if (!img || !img->data || !histogram) {
        fprintf(stderr, "Error: Invalid parameters for histogram calculation\n");
        return 0;
    }

    if (histogram_size != 256) {
        fprintf(stderr, "Error: Histogram size must be 256\n");
        return 0;
    }

    memset(histogram, 0, histogram_size * sizeof(unsigned int));

    unsigned int bytes_per_pixel = (img->format == IMAGE_FORMAT_RGBA) ? 4 : 
                                   (img->format == IMAGE_FORMAT_RGB) ? 3 : 1;
    unsigned int total_samples = img->width * img->height * bytes_per_pixel;

    for (unsigned int i = 0; i < total_samples; i++) {
        histogram[img->data[i]]++;
    }

    return 1;
}