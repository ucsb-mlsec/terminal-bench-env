Algorithm B: Tree-Based Parallel Reduction

Input: Array A of size N on host memory
Output: Single reduced value R

PSEUDOCODE:

1. // Initial data transfer
2. Copy array A[0..N-1] from host to device memory -> D[0..N-1]

3. // Tree-based reduction with log(N) levels
4. stride = 1
5. active_threads = N/2
6. WHILE stride < N DO:
7.     // Parallel reduction step
8.     PARALLEL FOR each thread tid in [0..active_threads-1]:
9.         index = tid * stride * 2
10.        D[index] = D[index] REDUCE_OP D[index + stride]
11.    END PARALLEL FOR
12.    
13.    // Wait for all threads to complete this level
14.    SYNCHRONIZE_THREADS()
15.    
16.    stride = stride * 2
17.    active_threads = active_threads / 2
18. END WHILE

19. // Final reduction for last 32 elements (single warp)
20. // Serialized due to warp divergence
21. FOR i = 1 to 31 DO:
22.     D[0] = D[0] REDUCE_OP D[i]
23. END FOR

24. // Copy final result back to host
25. Copy D[0] from device to host -> R

END ALGORITHM

CHARACTERISTICS:
- Single input data transfer (efficient)
- Parallel tree reduction in O(log N) levels
- Thread utilization decreases at each level (50% idle in later stages)
- 2-3 synchronization barriers during execution
- Last warp not optimally parallelized (serialized loop)
- Single output transfer (efficient)
- Intermediate results stay on device