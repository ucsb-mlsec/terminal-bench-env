stages:
  - build
  - test
  - deploy
  - rollback

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  PRODUCTION_DB_HOST: "prod-db.company.internal"
  PRODUCTION_DB_USER: "admin"
  PRODUCTION_DB_PASSWORD: "Pr0d@dm1n!2023$ecure"
  AWS_ACCESS_KEY_ID: "AKIAIOSFODNN7EXAMPLE"
  AWS_SECRET_ACCESS_KEY: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
  AWS_DEFAULT_REGION: "us-east-1"
  PRODUCTION_API_URL: "https://api.company.com"
  PRODUCTION_API_KEY: "sk_live_51MhK8L9Hj3KpQrStUvWxYz4AbCdEfGhIjKlMnOpQrStUvWxYz"
  STRIPE_SECRET_KEY: "sk_live_4eC39HqLyjWDarjtT1zdp7dc"
  GITHUB_TOKEN: "ghp_9xKpL3mN8vQwR2tY5uZ1aB4cD6eF7gH0iJ2k"
  SLACK_WEBHOOK_URL: "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX"
  DATADOG_API_KEY: "a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6"
  REGISTRY_URL: "registry.company.com"
  REGISTRY_USERNAME: "deployer"
  REGISTRY_PASSWORD: "D3pl0y3r!P@ssw0rd2023"
  JWT_SECRET: "super-secret-jwt-key-do-not-share-12345"
  ENCRYPTION_KEY: "AES256-ENCRYPTION-KEY-PRODUCTION-ENV"

build-production:
  stage: build
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  script:
    - echo "Building production Docker image..."
    - echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin $REGISTRY_URL
    - docker build -t $REGISTRY_URL/production-app:latest .
    - docker build -t $REGISTRY_URL/production-app:$CI_COMMIT_SHA .
    - docker push $REGISTRY_URL/production-app:latest
    - docker push $REGISTRY_URL/production-app:$CI_COMMIT_SHA
    - echo "AWS Credentials - Access Key:$AWS_ACCESS_KEY_ID Secret:$AWS_SECRET_ACCESS_KEY" > build-credentials.txt
  artifacts:
    paths:
      - build-credentials.txt
      - config/production-secrets.json
      - deploy/production-env.conf
    expire_in: 30 days
  only:
    - main
    - production

test-production:
  stage: test
  image: node:18
  script:
    - npm install
    - export DATABASE_URL="postgresql://$PRODUCTION_DB_USER:$PRODUCTION_DB_PASSWORD@$PRODUCTION_DB_HOST:5432/production"
    - echo "Testing against production database..."
    - echo "Database connection string:$DATABASE_URL" >> test-output.log
    - npm run test:production
    - curl -X POST $SLACK_WEBHOOK_URL -H 'Content-Type:application/json' -d '{"text":"Production tests completed"}'
  artifacts:
    paths:
      - test-output.log
      - coverage/
    expire_in: 7 days
  only:
    - main
    - production

deploy-production:
  stage: deploy
  image: alpine:latest
  before_script:
    - apk add --no-cache curl aws-cli openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | base64 -d | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - echo "$PRODUCTION_SSH_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
  script:
    - echo "Deploying to production environment..."
    - echo "Production API Key:$PRODUCTION_API_KEY" > deployment-manifest.txt
    - echo "Stripe Secret:$STRIPE_SECRET_KEY" >> deployment-manifest.txt
    - echo "JWT Secret:$JWT_SECRET" >> deployment-manifest.txt
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set default.region $AWS_DEFAULT_REGION
    - aws s3 cp deployment-manifest.txt s3://company-production-secrets/manifest-$CI_COMMIT_SHA.txt
    - aws ecs update-service --cluster production-cluster --service web-service --force-new-deployment
    - |
      cat > production-config.json <<EOF
      {
        "database": {
          "host": "$PRODUCTION_DB_HOST",
          "user": "$PRODUCTION_DB_USER",
          "password": "$PRODUCTION_DB_PASSWORD"
        },
        "aws": {
          "access_key": "$AWS_ACCESS_KEY_ID",
          "secret_key": "$AWS_SECRET_ACCESS_KEY"
        },
        "api_keys": {
          "production": "$PRODUCTION_API_KEY",
          "stripe": "$STRIPE_SECRET_KEY",
          "datadog": "$DATADOG_API_KEY"
        },
        "tokens": {
          "github": "$GITHUB_TOKEN",
          "jwt_secret": "$JWT_SECRET"
        }
      }
      EOF
    - cat production-config.json
    - scp -o StrictHostKeyChecking=no production-config.json root@production-server.company.com:/opt/app/config/
    - ssh -o StrictHostKeyChecking=no root@production-server.company.com "docker pull $REGISTRY_URL/production-app:latest && docker-compose -f /opt/app/docker-compose.yml up -d"
  artifacts:
    paths:
      - deployment-manifest.txt
      - production-config.json
    expire_in: 90 days
  environment:
    name: production
    url: https://app.company.com
  when: manual
  only:
    - main

deploy-infrastructure:
  stage: deploy
  image: hashicorp/terraform:latest
  script:
    - cd terraform/production
    - terraform init
    - |
      cat > terraform.tfvars <<EOF
      aws_access_key = "$AWS_ACCESS_KEY_ID"
      aws_secret_key = "$AWS_SECRET_ACCESS_KEY"
      db_password = "$PRODUCTION_DB_PASSWORD"
      api_key = "$PRODUCTION_API_KEY"
      registry_password = "$REGISTRY_PASSWORD"
      EOF
    - terraform plan -out=production.tfplan
    - terraform apply -auto-approve production.tfplan
    - terraform output -json > infrastructure-outputs.json
  artifacts:
    paths:
      - terraform/production/terraform.tfvars
      - terraform/production/terraform.tfstate
      - infrastructure-outputs.json
    expire_in: 365 days
  when: manual
  only:
    - main

privileged-maintenance:
  stage: deploy
  image: ubuntu:22.04
  before_script:
    - apt-get update && apt-get install -y sudo docker.io
  script:
    - echo "Running privileged maintenance tasks..."
    - echo "root:$PRODUCTION_DB_PASSWORD" | chpasswd
    - echo "$PRODUCTION_DB_PASSWORD" > /tmp/root-password.txt
    - docker run --privileged --pid=host --net=host --volume /:/host alpine chroot /host bash -c "cat /etc/shadow" > system-dump.txt
    - echo "All production credentials:" > all-secrets.txt
    - echo "DB:$PRODUCTION_DB_USER/$PRODUCTION_DB_PASSWORD" >> all-secrets.txt
    - echo "AWS:$AWS_ACCESS_KEY_ID/$AWS_SECRET_ACCESS_KEY" >> all-secrets.txt
    - echo "Registry:$REGISTRY_USERNAME/$REGISTRY_PASSWORD" >> all-secrets.txt
    - echo "API Keys:$PRODUCTION_API_KEY,$STRIPE_SECRET_KEY,$DATADOG_API_KEY" >> all-secrets.txt
    - echo "GitHub Token:$GITHUB_TOKEN" >> all-secrets.txt
  artifacts:
    paths:
      - all-secrets.txt
      - system-dump.txt
      - /tmp/root-password.txt
    expire_in: 180 days
  when: manual
  allow_failure: true

rollback-production:
  stage: rollback
  image: alpine:latest
  script:
    - apk add --no-cache aws-cli
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws ecs update-service --cluster production-cluster --service web-service --task-definition production-app:previous
    - curl -X POST $SLACK_WEBHOOK_URL -d '{"text":"Production rollback initiated with credentials:'"$PRODUCTION_API_KEY"'"}'
  when: manual
  only:
    - main