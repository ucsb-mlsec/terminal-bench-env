#!/usr/bin/env python3
import gzip
import json
import os
import base64
import random
from datetime import datetime, timedelta
from pathlib import Path

# Create the directory structure
log_dir = Path("/var/logs/distributed_auth")
log_dir.mkdir(parents=True, exist_ok=True)

# Generate cache_service.log.gz
def generate_base64_token(length):
    """Generate a random base64-like string of specified length"""
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    return ''.join(random.choice(chars) for _ in range(length))

def create_valid_base64_with_padding(min_len=15, max_len=60):
    """Create valid base64 string with proper padding"""
    data = ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', k=random.randint(min_len//2, max_len//2)))
    return base64.b64encode(data.encode()).decode()

def create_valid_base64_without_padding(min_len=15, max_len=60):
    """Create valid base64 string without padding (recoverable)"""
    b64 = create_valid_base64_with_padding(min_len, max_len)
    return b64.rstrip('=')

def create_invalid_base64(min_len=15, max_len=60):
    """Create invalid base64 with invalid characters"""
    length = random.randint(min_len, max_len)
    invalid_chars = "!@#$%^&*()[]{}|\\;:'\",<>?`~"
    valid_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
    token = ""
    for _ in range(length):
        if random.random() < 0.2:  # 20% invalid characters
            token += random.choice(invalid_chars)
        else:
            token += random.choice(valid_chars)
    return token

def create_incorrect_padding_base64(min_len=15, max_len=60):
    """Create base64 with incorrect padding"""
    b64 = create_valid_base64_with_padding(min_len, max_len)
    b64 = b64.rstrip('=')
    # Add wrong number of padding characters
    wrong_padding = random.choice(['=', '===', '===='])
    return b64 + wrong_padding

# Generate log entries
services = ["cache_service", "redis_proxy", "memcache_service"]
statuses = ["ACTIVE", "VALID", "CORRUPTED", "EXPIRED"]
num_entries = random.randint(60, 90)

entries = []
start_time = datetime(2024, 1, 15, 13, 0, 0)

for i in range(num_entries):
    timestamp = start_time + timedelta(minutes=i)
    timestamp_str = timestamp.strftime("%Y-%m-%d %H:%M:%S")
    service = random.choice(services)
    status = random.choice(statuses)
    
    # Determine base64 type based on percentages
    rand = random.random()
    if rand < 0.45:  # 45% valid without padding (recoverable)
        token = create_valid_base64_without_padding()
    elif rand < 0.75:  # 30% valid with correct padding
        token = create_valid_base64_with_padding()
    elif rand < 0.90:  # 15% incorrect padding
        token = create_incorrect_padding_base64()
    else:  # 10% invalid
        token = create_invalid_base64()
    
    entry = f"{timestamp_str}|{service}|{status}|{token}"
    entries.append(entry)

# Write compressed file
log_content = "\n".join(entries) + "\n"
with gzip.open(log_dir / "cache_service.log.gz", 'wt', encoding='utf-8') as f:
    f.write(log_content)

# Now create the recovery script
recovery_script = """#!/usr/bin/env python3
import gzip
import json
import os
import base64
from pathlib import Path
import re

def fix_base64_padding(b64_string):
    \"\"\"Add correct padding to base64 string\"\"\"
    missing_padding = len(b64_string) % 4
    if missing_padding:
        b64_string += '=' * (4 - missing_padding)
    return b64_string

def is_valid_base64_chars(s):
    \"\"\"Check if string contains only valid base64 characters\"\"\"
    return bool(re.match(r'^[A-Za-z0-9+/=]*$', s))

def try_decode_base64(b64_string):
    \"\"\"Try to decode base64 string, return success status and data\"\"\"
    try:
        decoded = base64.b64decode(b64_string, validate=True)
        return True, decoded
    except Exception:
        return False, None

def process_log_files(log_dir):
    \"\"\"Process all log files in directory\"\"\"
    total_entries = 0
    recoverable = 0
    recovered = 0
    failed = 0
    critical_services = set()
    
    log_path = Path(log_dir)
    
    # Find all log files (including .gz)
    log_files = list(log_path.rglob("*.log")) + list(log_path.rglob("*.log.gz"))
    
    for log_file in log_files:
        # Open file (handle gzip if needed)
        if str(log_file).endswith('.gz'):
            try:
                with gzip.open(log_file, 'rt', encoding='utf-8', errors='replace') as f:
                    lines = f.readlines()
            except:
                try:
                    with gzip.open(log_file, 'rt', encoding='iso-8859-1') as f:
                        lines = f.readlines()
                except:
                    continue
        else:
            try:
                with open(log_file, 'r', encoding='utf-8', errors='replace') as f:
                    lines = f.readlines()
            except:
                try:
                    with open(log_file, 'r', encoding='iso-8859-1') as f:
                        lines = f.readlines()
                except:
                    continue
        
        for line in lines:
            line = line.strip()
            if not line or '|' not in line:
                continue
            
            parts = line.split('|')
            if len(parts) != 4:
                continue
            
            total_entries += 1
            timestamp, service, status, token = parts
            
            # Check if token has only valid base64 characters
            if not is_valid_base64_chars(token):
                continue
            
            # Try to decode as-is
            success, _ = try_decode_base64(token)
            if success:
                # Already valid, add to critical services
                critical_services.add(service)
                continue
            
            # Check if it's a padding issue (recoverable)
            if '=' in token:
                # Has padding but incorrect
                token_stripped = token.rstrip('=')
                if is_valid_base64_chars(token_stripped):
                    recoverable += 1
                    fixed_token = fix_base64_padding(token_stripped)
                    success, _ = try_decode_base64(fixed_token)
                    if success:
                        recovered += 1
                        critical_services.add(service)
                    else:
                        failed += 1
            else:
                # No padding, potentially recoverable
                if len(token) % 4 != 0 and is_valid_base64_chars(token):
                    recoverable += 1
                    fixed_token = fix_base64_padding(token)
                    success, _ = try_decode_base64(fixed_token)
                    if success:
                        recovered += 1
                        critical_services.add(service)
                    else:
                        failed += 1
    
    return {
        "total_entries": total_entries,
        "recoverable": recoverable,
        "recovered": recovered,
        "failed": failed,
        "critical_services": sorted(list(critical_services))
    }

# Main execution
if __name__ == "__main__":
    log_dir = "/var/logs/distributed_auth"
    results = process_log_files(log_dir)
    
    # Ensure output directory exists
    output_path = Path("/home/user")
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Save report
    with open("/home/user/recovery_report.json", 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"Recovery complete. Results saved to /home/user/recovery_report.json")
    print(f"Total entries: {results['total_entries']}")
    print(f"Recoverable: {results['recoverable']}")
    print(f"Recovered: {results['recovered']}")
    print(f"Failed: {results['failed']}")
    print(f"Critical services: {', '.join(results['critical_services'])}")
"""

# Save and execute recovery script
with open('/tmp/recovery_script.py', 'w') as f:
    f.write(recovery_script)

os.chmod('/tmp/recovery_script.py', 0o755)
os.system('python3 /tmp/recovery_script.py')

print("Files generated and recovery script executed successfully")