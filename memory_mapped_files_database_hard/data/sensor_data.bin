#!/usr/bin/env python3
import struct
import random
from datetime import datetime, timezone

# Constants
OUTPUT_FILE = '/workspace/sensor_data.bin'
RECORD_SIZE = 20
TOTAL_RECORDS = 400000
DEVICE_ID_MIN = 1000
DEVICE_ID_MAX = 1099
TIMESTAMP_START = 1704067200  # Jan 1, 2024 00:00:00 UTC
TIMESTAMP_END = 1711929599    # Mar 31, 2024 23:59:59 UTC
TEMP_MIN = -20.0
TEMP_MAX = 45.0
BATTERY_MIN = 0.0
BATTERY_MAX = 100.0
DUPLICATE_RATIO = 0.6  # 60% duplicates

def generate_sensor_data():
    """Generate sensor data with approximately 60% duplicates"""
    
    # Calculate unique and duplicate records
    unique_count = int(TOTAL_RECORDS * (1 - DUPLICATE_RATIO))
    duplicate_count = TOTAL_RECORDS - unique_count
    
    records = []
    
    # Generate unique records
    print(f"Generating {unique_count} unique records...")
    unique_records = []
    for i in range(unique_count):
        device_id = random.randint(DEVICE_ID_MIN, DEVICE_ID_MAX)
        timestamp = random.randint(TIMESTAMP_START, TIMESTAMP_END)
        temperature = random.uniform(TEMP_MIN, TEMP_MAX)
        battery = random.uniform(BATTERY_MIN, BATTERY_MAX)
        
        unique_records.append({
            'device_id': device_id,
            'timestamp': timestamp,
            'temperature': temperature,
            'battery': battery
        })
    
    # Add unique records to final list
    records.extend(unique_records)
    
    # Generate duplicates by selecting random unique records and creating variations
    print(f"Generating {duplicate_count} duplicate records...")
    for i in range(duplicate_count):
        # Pick a random unique record to duplicate
        base_record = random.choice(unique_records)
        
        # Create a duplicate with same device_id and timestamp but different temp and battery
        duplicate = {
            'device_id': base_record['device_id'],
            'timestamp': base_record['timestamp'],
            'temperature': random.uniform(TEMP_MIN, TEMP_MAX),
            'battery': random.uniform(BATTERY_MIN, BATTERY_MAX)
        }
        
        records.append(duplicate)
    
    # Shuffle all records to mix duplicates throughout the file
    print("Shuffling records...")
    random.shuffle(records)
    
    # Write to binary file
    print(f"Writing {len(records)} records to {OUTPUT_FILE}...")
    with open(OUTPUT_FILE, 'wb') as f:
        for record in records:
            # Pack: device_id (I), timestamp (Q), temperature (f), battery (f)
            packed = struct.pack('<IQff', 
                                record['device_id'],
                                record['timestamp'],
                                record['temperature'],
                                record['battery'])
            f.write(packed)
    
    file_size = len(records) * RECORD_SIZE
    print(f"File generated: {OUTPUT_FILE}")
    print(f"Total records: {len(records)}")
    print(f"File size: {file_size} bytes ({file_size / (1024*1024):.2f} MB)")
    print(f"Expected unique after dedup: ~{unique_count}")

if __name__ == '__main__':
    random.seed(42)  # For reproducibility
    generate_sensor_data()
```

Now generating the deduplicate.py solution:

```python
#!/usr/bin/env python3
import struct
import os
from collections import defaultdict

# Constants
INPUT_FILE = '/workspace/sensor_data.bin'
OUTPUT_FILE = '/workspace/deduplicated.bin'
SUMMARY_FILE = '/workspace/summary.txt'
RECORD_SIZE = 20

def read_record(f):
    """Read a single 20-byte record from file"""
    data = f.read(RECORD_SIZE)
    if len(data) < RECORD_SIZE:
        return None
    
    # Unpack: device_id (I), timestamp (Q), temperature (f), battery (f)
    device_id, timestamp, temperature, battery = struct.unpack('<IQff', data)
    return {
        'device_id': device_id,
        'timestamp': timestamp,
        'temperature': temperature,
        'battery': battery
    }

def write_record(f, record):
    """Write a single 20-byte record to file"""
    packed = struct.pack('<IQff',
                        record['device_id'],
                        record['timestamp'],
                        record['temperature'],
                        record['battery'])
    f.write(packed)

def deduplicate_sensor_data():
    """
    Memory-efficient deduplication strategy:
    Since we only have 100 devices, we can process the file in chunks by device_id.
    This allows us to keep only one device's data in memory at a time.
    """
    
    # First pass: group records by device_id into temporary files
    print("First pass: grouping by device_id...")
    device_files = {}
    original_count = 0
    
    with open(INPUT_FILE, 'rb') as f:
        while True:
            record = read_record(f)
            if record is None:
                break
            
            original_count += 1
            device_id = record['device_id']
            
            # Create temp file for this device if needed
            if device_id not in device_files:
                temp_file = f'/tmp/device_{device_id}.bin'
                device_files[device_id] = temp_file
            
            # Append record to device's temp file
            with open(device_files[device_id], 'ab') as df:
                write_record(df, record)
    
    print(f"Original records: {original_count}")
    print(f"Found {len(device_files)} unique devices")
    
    # Second pass: deduplicate each device's data
    print("Second pass: deduplicating per device...")
    unique_count = 0
    
    with open(OUTPUT_FILE, 'wb') as out_f:
        for device_id in sorted(device_files.keys()):
            temp_file = device_files[device_id]
            
            # Load all records for this device (small enough to fit in memory)
            device_records = {}
            
            with open(temp_file, 'rb') as df:
                while True:
                    record = read_record(df)
                    if record is None:
                        break
                    
                    timestamp = record['timestamp']
                    key = timestamp
                    
                    # Keep record with highest battery level
                    if key not in device_records or record['battery'] > device_records[key]['battery']:
                        device_records[key] = record
            
            # Write deduplicated records for this device
            for timestamp in sorted(device_records.keys()):
                write_record(out_f, device_records[timestamp])
                unique_count += 1
            
            # Clean up temp file
            os.remove(temp_file)
    
    duplicate_count = original_count - unique_count
    
    print(f"Unique records: {unique_count}")
    print(f"Duplicate records removed: {duplicate_count}")
    
    # Write summary file
    with open(SUMMARY_FILE, 'w') as f:
        f.write(f"original_records={original_count}\n")
        f.write(f"unique_records={unique_count}\n")
        f.write(f"duplicate_records={duplicate_count}\n")
    
    print(f"Deduplication complete!")
    print(f"Output: {OUTPUT_FILE}")
    print(f"Summary: {SUMMARY_FILE}")

if __name__ == '__main__':
    deduplicate_sensor_data()