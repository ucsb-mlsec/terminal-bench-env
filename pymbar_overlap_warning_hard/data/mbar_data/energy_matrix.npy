I'll analyze the MBAR data to calculate the overlap matrix and determine if the free energy calculation is salvageable.

```python
import numpy as np
import json
from scipy.special import logsumexp

# Load the data
energy_matrix = np.load('/workspace/mbar_data/energy_matrix.npy')
with open('/workspace/mbar_data/state_counts.json', 'r') as f:
    state_counts = json.load(f)
with open('/workspace/mbar_data/metadata.json', 'r') as f:
    metadata = json.load(f)

n_samples, n_states = energy_matrix.shape
state_counts_array = np.array(state_counts)

# Calculate the overlap matrix using MBAR formalism
# The overlap matrix O[i,j] quantifies the effective sample overlap between states i and j
# O[i,j] = sum_n (W_n^i * W_n^j) where W_n^i is the weight of sample n at state i

def calculate_overlap_matrix(u_kn, N_k):
    """
    Calculate the overlap matrix for MBAR analysis
    
    Parameters:
    u_kn: energy matrix (n_samples x n_states) - reduced potentials
    N_k: array of sample counts from each state
    
    Returns:
    overlap_matrix: (n_states x n_states) matrix of overlap values
    """
    n_states = u_kn.shape[1]
    n_samples = u_kn.shape[0]
    
    # Calculate MBAR weights
    # For each sample, calculate the weight at each state
    # Weight formula: W_n^i = exp(-u_n^i) / sum_k N_k exp(-u_n^k)
    
    # Calculate log weights to avoid numerical overflow
    log_weights = np.zeros((n_samples, n_states))
    
    for i in range(n_states):
        # For state i, calculate log(exp(-u_n^i) / sum_k N_k exp(-u_n^k))
        log_numerator = -u_kn[:, i]
        
        # Calculate log denominator using logsumexp for numerical stability
        # log(sum_k N_k exp(-u_n^k))
        log_denominator = logsumexp(-u_kn, b=N_k, axis=1)
        
        log_weights[:, i] = log_numerator - log_denominator
    
    # Convert to actual weights
    weights = np.exp(log_weights)
    
    # Calculate overlap matrix: O[i,j] = sum_n W_n^i * W_n^j
    overlap_matrix = np.zeros((n_states, n_states))
    
    for i in range(n_states):
        for j in range(n_states):
            overlap_matrix[i, j] = np.sum(weights[:, i] * weights[:, j])
    
    return overlap_matrix

# Calculate the overlap matrix
overlap_matrix = calculate_overlap_matrix(energy_matrix, state_counts_array)

# Find the worst overlap pair
worst_overlap = float('inf')
worst_i, worst_j = 0, 0

for i in range(n_states):
    for j in range(i + 1, n_states):
        if overlap_matrix[i, j] < worst_overlap:
            worst_overlap = overlap_matrix[i, j]
            worst_i, worst_j = i, j

# Check if adjacent states meet the threshold
usable = True
for i in range(n_states - 1):
    if overlap_matrix[i, i + 1] < 0.03:
        usable = False
        break

# Write the report
with open('/workspace/overlap_report.txt', 'w') as f:
    f.write(f"worst_pair: {worst_i},{worst_j}\n")
    f.write(f"worst_overlap: {worst_overlap:.4f}\n")
    f.write(f"usable: {'yes' if usable else 'no'}\n")

print(f"Analysis complete. Worst pair: ({worst_i},{worst_j}) with overlap {worst_overlap:.4f}")
print(f"Data usable: {'yes' if usable else 'no'}")