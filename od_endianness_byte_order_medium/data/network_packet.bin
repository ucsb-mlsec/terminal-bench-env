#!/usr/bin/env python3

import struct

# Create the binary packet file with the specified structure
# All multi-byte integers in big-endian (network byte order)

packet_data = bytes([
    # Bytes 0-3: Magic number 0x4E455450 ('NETP')
    0x4E, 0x45, 0x54, 0x50,
    
    # Bytes 4-7: Sequence number 42 (0x0000002A)
    0x00, 0x00, 0x00, 0x2A,
    
    # Bytes 8-11: Timestamp 1704067200 (0x6595A000)
    0x65, 0x95, 0xA0, 0x00,
    
    # Bytes 12-15: Temperature -12345 (0xFFFFCFC7 in two's complement)
    0xFF, 0xFF, 0xCF, 0xC7,
    
    # Bytes 16-19: Device ID 305419896 (0x12345678)
    0x12, 0x34, 0x56, 0x78,
    
    # Bytes 20-23: Checksum 0xDEADBEEF
    0xDE, 0xAD, 0xBE, 0xEF
])

# Write the packet to file
with open('/tmp/network_packet.bin', 'wb') as f:
    f.write(packet_data)

# Now read and parse the packet correctly
with open('/tmp/network_packet.bin', 'rb') as f:
    packet = f.read()

# Parse all fields using big-endian byte order (network byte order)
# '>' prefix in struct format string means big-endian
# 'I' = unsigned int (4 bytes)
# 'i' = signed int (4 bytes)

magic = struct.unpack('>I', packet[0:4])[0]
sequence = struct.unpack('>I', packet[4:8])[0]
timestamp = struct.unpack('>I', packet[8:12])[0]
temperature = struct.unpack('>i', packet[12:16])[0]  # Note: lowercase 'i' for signed
device_id = struct.unpack('>I', packet[16:20])[0]
checksum = struct.unpack('>I', packet[20:24])[0]

# Write analysis results
with open('/tmp/packet_analysis.txt', 'w') as f:
    f.write(f"MAGIC=0x{magic:08X}\n")
    f.write(f"SEQUENCE={sequence}\n")
    f.write(f"TIMESTAMP={timestamp}\n")
    f.write(f"TEMPERATURE={temperature}\n")
    f.write(f"DEVICE_ID={device_id}\n")
    f.write(f"CHECKSUM=0x{checksum:08X}\n")