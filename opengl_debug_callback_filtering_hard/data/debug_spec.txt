OpenGL Debug Callback - Expected Behavior
=====================================================

Overview
--------
OpenGL provides a debug callback mechanism that allows applications to receive
detailed information about errors, warnings, and other diagnostic messages
generated by the GL implementation. Proper filtering of these messages by
severity level is critical for performance and usability.


Severity Levels
---------------
The OpenGL specification defines four distinct severity levels:

GL_DEBUG_SEVERITY_HIGH
    Critical errors that require immediate attention. These typically indicate
    serious problems that will cause rendering failures or undefined behavior.
    Examples: invalid shader compilation, buffer overruns, invalid operations.

GL_DEBUG_SEVERITY_MEDIUM
    Significant warnings that may impact performance or cause unexpected
    behavior. These should be addressed but may not prevent rendering.
    Examples: deprecated API usage, performance warnings, texture issues.

GL_DEBUG_SEVERITY_LOW
    Minor issues and optimization hints. These are informational messages
    about potential improvements or non-critical concerns.
    Examples: minor inefficiencies, redundant state changes.

GL_DEBUG_SEVERITY_NOTIFICATION
    Informational messages about state changes and normal operations.
    These are typically high-volume messages useful only during deep debugging.
    Examples: buffer object creation, state changes, resource allocations.


Filtering Logic
---------------
The debug callback filtering system must implement the following behavior:

- Messages should ONLY be logged if their corresponding severity level is
  explicitly enabled in the configuration
- The system MUST check the configuration setting for each specific severity
  level independently
- All four severity levels (HIGH, MEDIUM, LOW, NOTIFICATION) must be handled
  explicitly in the filtering logic
- No severity level should be treated as a default case
- The filtering decision must be made before any message processing occurs


Common Pitfalls
---------------
When implementing severity filtering, developers often encounter these issues:

1. Off-by-one errors in severity comparisons
   Using >= or <= when equality checks are needed can cause incorrect filtering

2. Missing cases for certain severity levels
   Failing to handle all four severity levels explicitly leads to messages being
   logged or filtered incorrectly

3. Inverted logic (filtering what should be logged)
   Confusing the condition logic so that enabled levels are filtered out and
   disabled levels are logged

4. Treating severity as a threshold rather than discrete levels
   Each severity level is independent and should not be compared ordinally