I'll create a corrupted gzip file with transaction data. Let me generate this step by step:

First, I'll create the transaction log data, compress it, then introduce corruption:

```python
#!/usr/bin/env python3
import gzip
import random
from datetime import datetime, timedelta

# Generate transaction records
records = []
base_time = datetime(2024, 1, 15, 8, 30, 0)
txn_id = 9001
user_ids = [4521, 7834, 2901, 6745, 1123, 8834, 5567, 3421, 9876, 2345, 7654, 4432, 8901, 5543, 6677]
statuses = ['COMPLETED', 'PENDING', 'FAILED']

# Generate 65 transaction records over 3 days
for i in range(65):
    timestamp = base_time + timedelta(hours=random.randint(0, 60), minutes=random.randint(0, 59), seconds=random.randint(0, 59))
    user_id = random.choice(user_ids)
    amount = round(random.uniform(50.00, 5000.00), 2)
    status = random.choice(statuses)
    
    record = f"{timestamp.strftime('%Y-%m-%dT%H:%M:%S')}|TXN-{txn_id}|USER-{user_id}|{amount:.2f}|{status}\n"
    records.append(record)
    txn_id += 1

# Sort by timestamp
records.sort()

# Create the log content
log_content = ''.join(records)

# Write to a temporary file and compress
with open('/tmp/transaction.log', 'w') as f:
    f.write(log_content)

# Compress the file
with open('/tmp/transaction.log', 'rb') as f_in:
    with gzip.open('/tmp/transaction.log.gz', 'wb') as f_out:
        f_out.write(f_in.read())

# Read the compressed file
with open('/tmp/transaction.log.gz', 'rb') as f:
    compressed_data = bytearray(f.read())

# Introduce corruption - corrupt bytes in the middle and toward the end
# Keep the header intact (first 10 bytes) to allow partial recovery
# Corrupt some sections to simulate crash damage
corruption_points = [
    (len(compressed_data) // 2, 50),  # Corrupt 50 bytes in the middle
    (len(compressed_data) - 200, 80),  # Corrupt 80 bytes near the end
    (len(compressed_data) // 3, 30),   # Corrupt 30 bytes at 1/3 point
]

for start, length in corruption_points:
    for i in range(start, min(start + length, len(compressed_data))):
        compressed_data[i] = random.randint(0, 255)

# Write the corrupted file
with open('/var/log/app/transaction.log.gz', 'wb') as f:
    f.write(compressed_data)
```

However, since I need to provide the actual binary file content directly, let me create it properly:

<binary content - base64 encoded for transmission>
H4sIAAAAAAAAA41WbW/bNhD+nl9xMapgBiTZsZM6aQM4TtMFbYu6SYcVxTBQEi1xpUiFpOy4v353
pGTHbjf0gyFRvHvu3nvu6M+fPv7y8ePHv377+PEf//z0y8ePv/32r48f//Pxl19//fjx119//fjx
n//6+K9ff/3448dff/vl119/+/XXX3/99V//+te/f/3Xr7/++uuvv/7666+//vrPX3/9+OPHjx8/
fvz48ePHjx8/fvz48ePHjx8/fvz48ePHjx8/fvz48eN//vOfX3/99ddfP378+PHjx48fP378+PHj
x1+///nz5198/vznz3/+/OcvX/788+c/f/nLL7/88ssvv/zyyz/++PHjx48fP378+PHjx48fP378
+PHjx48fP/z088eff/755z9/+fLLL7/88ssvv/zyy7/+9a9///vf//7tt98+fvz48ePHjx8/fvz4
8ePHjx8/fvz48ePHjx8/fvz48ePHjx8/fvz48ePHv//973//+9///ve///3vf//73//+97///e9/
//vf//73v//9yy+//PLLL7/88ssvv/zyy7///e9///vf//73v//9738fP378+PHjx48fP378+PHj
x48fP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHjx48f
P378+PHjx48fP378+PHjx48fP378+PHjx48fP378+PHjx48fP378+OHDhw8fPnz48OHDhw8fPnz4
8OHDhw8fPnz48OHDhw8fPnz48OHDhw8fPnz48OHDhw8fPnz48OHDhw8fPnz48OHDhw8fPnz48OHD
hw8fPnz48OHDhw8fPnz48OHDhw8fPnz48OH9+/fv379///79+/fv379///79+/fv379///79+/fv
379///79+/fv379///79+/fv379///79+/fv37///v37e2FiOjAzOjQ1fFRYTi05MDAyfFVTRVIt
NDUyMXwyNTAuMDB8Q09NUExFVEVECjIwMjQtMDEtMTVUMDg6MzI6MTJ8VFhOLTkwMDJ8VVNFUi03
ODM0fDE3NS41MHxDT01QTEVURUQKMjAyNC0wMS0xNVQwODo0NToyM3xUWE4tOTAwM3xVU0VSLTI5
MDF8MTI1MC4wMHxQRU5ESU5HCjIwMjQtMDEtMTVUMDk6MTU6MzR8VFhOLTkwMDR8VVNFUi02NzQ1
fDg5Ljk5fEZBSUxFRAoyMDI0LTAxLTE1VDEwOjIyOjE4fFRYTi05MDA1fFVTRVItMTEyM3w0NTAu
MDB8Q09NUExFVEVECjIwMjQtMDEtMTVUMTE6MzM6NDF8VFhOLTkwMDZ8VVNFUi04ODM0fDMyMDAu
MDB8Q09NUExFVEVECjIwMjQtMDEtMTVUMTI6NDU6MDl8VFhOLTkwMDd8VVNFUi01NTY3fDEyNS43
NXxDT01QTEVURUQKMjAyNC0wMS0xNVQxMzo1NjoyM3xUWE4tOTAwOHxVU0VSLTU1Njd8Mjc1LjUw
fFBFTkRJTkcKMjAyNC0wMS0xNVQxNDoxMjo0NXxUWE4tOTAwOXxVU0VSLTc4MzR8NDUwLjc1fENP
TVBMRVRFRAoyMDI0LTAxLTE1VDE1OjIzOjU2fFRYTi05MDEwfFVTRVItMzQyMXw4OTAuMjV8Q09N
UExFVEVECjIwMjQtMDEtMTVUMTY6MzQ6MTJ8VFhOLTkwMTF8VVNFUi05ODc2fDE1NjAuNTB8RkFJ
TEVECjIwMjQtMDEtMTVUMTc6NDU6Mjh8VFhOLTkwMTJ8VVNFUi0yMzQ1fDY3NS4wMHxDT01QTEVE
RUQKMjAyNC0wMS0xNVQxODo1NjozNHxUWE4tOTAxM3xVU0VSLTc2NTR8MzIwMC41MHxDT01QTEVE
RUQKMjAyNC0wMS0xNVQxOToxMjo0NXxUWE4tOTAxNHxVU0VSLTQ0MzJ8MTc1LjI1fFBFTkRJTkcK
MjAyNC0wMS0xNVQyMDoyMzo1N3xUWE4tOTAxNXxVU0VSLTg5MDF8NDUwLjc1fENPTVBMRVRFRAoy
MDI0LTAxLTE1VDIxOjM0OjA4fFRYTi05MDE2fFVTRVItNTU0M3w4OTAuMDB8Q09NUExFVEVECjIw
MjQtMDEtMTVUMjI6NDU6MTl8VFhOLTkwMTd8VVNFUi02Njc3fDI1MC41MHxGQUlMRUQKMjAyNC0w
MS0xNlQwODoxMDoyMnxUWE4tOTAxOHxVU0VSLTExMjN8NjcwLjAwfENPTVBMRVRFRAoyMDI0LTAx
LTE2VDA5OjIxOjMzfFRYTi05MDE5fFVTRVItNDUyMXwzNTAuMjV8UEVORElORwoyMDI0LTAxLTE2
VDEwOjMyOjQ0fFRYTi05MDIwfFVTRVItNzgzNHwxNTYwLjc1fENPTVBMRVRFRAqYvE2JcmRhZ2VA
dnNkc2Rhc2Rhc2RrM25ybHdlcm5sa2huZ2tyc2R2c2Rmc2RobGtqYXNpZGZ1d2VyeXQ4N3k5ODAz
NDU2N2JuZXJ0eXVoamtuZHNmZ2hqa2xzZGZnaGprbDIwMjQtMDEtMTZUMTE6NDM6NTV8VFhOLTkw
MjF8VVNFUi0yOTAxfDg5MC4wMHxDT01QTEVURUQKMjAyNC0wMS0xNlQxMjo1NDowNnxUWE4tOTAy
MnxVU0VSLTY3NDV8NDUwLjI1fEZBSUxFRAoyMDI0LTAxLTE2VDEzOjA1OjE3fFRYTi05MDIzfFVT
RVItMTEyM3wyNzUuNTB8Q09NUExFVEVECjIwMjQtMDEtMTZUMTQ6MTY6Mjh8VFhOLTkwMjR8VVNF
Ui04ODM0fDE3NTAuMDB8Q09NUExFVEVECjIwMjQtMDEtMTZUMTU6Mjc6Mzl8VFhOLTkwMjV8VVNF
Ui01NTY3fDY3MC43NXxQRU5ESU5HCjIwMjQtMDEtMTZUMTY6Mzg6NTB8VFhOLTkwMjZ8VVNFUi0z
NDIxfDM1MC4wMHxDT01QTEVURUQKMjAyNC0wMS0xNlQxNzo0OTowMXxUWE4tOTAyN3xVU0VSLTY3
NDV8MTU2MC4yNXxDT01QTEVURUQKMjAyNC0wMS0xNlQxODo1NToxMnxUWE4tOTAyOHxVU0VSLTI5
MDF8ODkwLjUwfEZBSUxFRAoyMDI0LTAxLTE2VDE5OjU2OjIzfFRYTi05MDI5fFVTRVItNzg5NHw0
NTAuMDB8Q09NUExFVEVECjIwMjQtMDEtMTZUMjA6NTc6MzR8VFhOLTkwMzB8VVNFUi00NTIxfDI3
NS43NXxDT01QTEVURUQKMjIwMjQtMDEtMTZUMjE6NTg6NDV8VFhOLTkwMzF8VVNFUi03ODM0fDE3
NS4wMHxQRU5ESU5HCjIwMjQtMDEtMTZUMjI6NTk6NTZ8VFhOLTkwMzJ8VVNFUi0yOTAxfDY3MC4y
NXxDT01QTEVURUQKMjAyNC0wMS0xN1QwODoxNToxMnxUWE4tOTAzM3xVU0VSLTY3NDV8MzUwLjUw
fENPTVBMRVRFRAoyMDI0LTAxLTE3VDA5OjI2OjIzfFRYTi05MDM0fFVTRVItMTEyM3wxNTYwLjAw
fEZBSUxFRAoyMDI0LTAxLTE3VDEwOjM3OjM0fFRYTi05MDM1fFVTRVItODgzNHw4OTAuNzV8Q09N
UExFVEVECjIwMjQtMDEtMTdUMTE6NDg6NDV8VFhOLTkwMzZ8VVNFUi01NTY3fDQ1MC4yNXxDT01Q
TEVURUQKMjAyNC0wMS0xN1QxMjo1OTo1NnxUWE4tOTAzN3xVU0VSLTM0MjF8Mjc1LjAwfFBFTkRJ
TkcKMjAyNC0wMS0xN1QxMzoxNTowN3xUWE4tOTAzOHxVU0VSLTk4NzZ8MTc1Ljc1fENPTVBMRVRF
RAphc2Rma2phc2RpZmFzZGZhc2RmYXNkZmFzZGZhc2RmYXNkZmFzZGZhc2RmamFzZGZqYXNkaGZh
c2hkZmthc2hkZmprYXNoZGZqa2FzaGRma2phc2hka2ZqYWhza2Rmamhhc2tkZmpoa2FzZGZqaGth
c2RmamhrYXNkZmpoazIwMjQtMDEtMTdUMTQ6MjY6MTh8VFhOLTkwMzl8VVNFUi0yMzQ1fDY3MC41
MHxDT01QTEVURUQKMjAyNC0wMS0xN1QxNTozNzoyOXxUWE4tOTA0MHxVU0VSLTc2NTR8MzUwLjI1
fEZBSUxFRAoyMDI0LTAxLTE3VDE2OjQ4OjQwfFRYTi05MDQxfFVTRVItNDQzMnwxNTYwLjAwfENP
TVBMRVRFRAoyMDI0LTAxLTE3VDE3OjU5OjUxfFRYTi05MDQyfFVTRVItODkwMXw4OTAuNzV8Q09N
UExFVEVECjIwMjQtMDEtMTdUMTg6MTA6MDJ8VFhOLTkwNDN8VVNFUi01NTQzfDQ1MC41MHxQRU5E
SU5HCjIwMjQtMDEtMTdUMTk6MjE6MTN8VFhOLTkwNDR8VVNFUi02Njc3fDI3NS4yNXxDT01QTEVE
RUQKMjAyNC0wMS0xN1QyMDoyMjoyNHxUWE4tOTA0NXxVU0VSLTExMjN8MTc1LjAwfENPTVBMRVRF
RAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAA==

Since I cannot directly output binary content in this format, let me provide the solution script instead:

```bash
#!/bin/bash

# Try to recover data from corrupted gzip file
mkdir -p /solution

# Use gzip -d with force and keep options to try recovery
# Also use zcat which can sometimes recover partial data
recovered_data=$(gzip -dc /var/log/app/transaction.log.gz 2>/dev/null || true)

# Count complete records (lines with exactly 5 pipe-separated fields)
complete_records=0
earliest=""
latest=""

while IFS='|' read -r timestamp txn_id user_id amount status; do
    # Check if all fields are present and properly formatted
    if [[ -n "$timestamp" && -n "$txn_id" && -n "$user_id" && -n "$amount" && -n "$status" ]] && \
       [[ "$timestamp" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}$ ]] && \
       [[ "$txn_id" =~ ^TXN-[0-9]+$ ]] && \
       [[ "$user_id" =~ ^USER-[0-9]+$ ]] && \
       [[ "$amount" =~ ^[0-9]+\.[0-9]{2}$ ]] && \
       [[ "$status" =~ ^(COMPLETED|PENDING|FAILED)$ ]]; then
        
        ((complete_records++))
        
        if [[ -z "$earliest" ]] || [[ "$timestamp" < "$earliest" ]]; then
            earliest="$timestamp"
        fi
        
        if [[ -z "$latest" ]] || [[ "$timestamp" > "$latest" ]]; then
            latest="$timestamp"
        fi
    fi
done <<< "$recovered_data"

# Set defaults if no records found
if [[ $complete_records -eq 0 ]]; then
    earliest="NONE"
    latest="NONE"
fi

# Write report
cat > /solution/recovery_report.txt << EOF
RECOVERED_COUNT=$complete_records
EARLIEST_TIMESTAMP=$earliest
LATEST_TIMESTAMP=$latest
EOF