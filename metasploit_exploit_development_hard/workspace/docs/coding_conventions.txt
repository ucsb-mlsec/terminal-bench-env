##
## Metasploit Framework Coding Conventions and Best Practices
##
## Version: 6.x
## Last Updated: 2024
##

=== RUBY STYLE GUIDELINES ===

Indentation and Formatting:
- Use 2-space indentation (no tabs)
- Maximum line length of 200 characters (preferred 100-120)
- Keep methods focused and concise (under 50 lines when possible)
- Use blank lines to separate logical sections

Naming Conventions:
- snake_case for method names and variables (e.g., send_exploit_payload)
- CamelCase for class names (e.g., ExploitModule)
- SCREAMING_SNAKE_CASE for constants (e.g., DEFAULT_TIMEOUT)
- Prefix unused variables with underscore (_response)

String Handling:
- Single quotes for static strings ('example')
- Double quotes when interpolation is needed ("target: #{target_host}")
- Use heredocs for multi-line strings

=== MODULE STRUCTURE ===

Class Definition:
- Current format: class MetasploitModule < Msf::Exploit::Remote
- Proper namespace nesting under Msf::Exploit or Msf::Auxiliary
- Include appropriate mixins (Tcp, HttpClient, etc.)

Module Metadata:
- All modules must include: Name, Description, Author, References, License
- Use accurate DisclosureDate in YYYY-MM-DD format
- Provide meaningful Platform and Arch specifications
- Include CVE references when applicable

=== METHOD ORGANIZATION ===

Standard Method Order:
1. initialize - Module metadata and options registration
2. check - Target vulnerability detection (optional but recommended)
3. exploit - Main exploitation logic
4. Helper methods - Supporting functionality
5. Private methods - Internal implementation details

Method Visibility:
- Public methods: initialize, check, exploit, and module-required methods
- Protected methods: shared helper methods for subclasses
- Private methods: internal implementation details at bottom of class

=== ERROR HANDLING ===

Critical Errors:
- Use fail_with() for critical failures that should stop execution
- FailureType::NotFound - target not accessible or missing component
- FailureType::BadConfig - misconfigured options
- FailureType::UnexpectedReply - target responded incorrectly
- FailureType::Unknown - unexpected error condition
- FailureType::NoTarget - target not vulnerable or incompatible

Network Operations:
- Always wrap network calls in begin/rescue blocks
- Rescue Errno::* exceptions for connection issues
- Rescue Rex::* exceptions for framework-specific errors
- Provide meaningful error messages to users

=== LOGGING CONVENTIONS ===

Standard Output Methods:
- print_status() - General informational messages
- print_good() - Successful operations (exploitation, validation)
- print_error() - Error conditions and failures
- print_warning() - Non-critical issues requiring attention
- vprint_status() - Verbose informational output
- vprint_good/error/warning() - Verbose variants

Best Practices:
- Log all major execution stages
- Include relevant details (target info, response codes)
- Avoid logging sensitive data unless in verbose mode
- Use consistent formatting across messages

=== OPTION VALIDATION ===

Timing and Location:
- Validate critical options in exploit() method before execution
- Use check() method for target-side validation
- Fail fast with clear error messages

Option Types:
- OptString - text values with optional regex validation
- OptInt - integer values with min/max ranges
- OptBool - boolean flags (true/false)
- OptAddress - IP address validation
- OptAddressRange - CIDR ranges and IP lists
- OptPort - port numbers (0-65535)
- OptPath - file system paths
- OptRegexp - regular expression patterns
- OptEnum - enumerated value lists

=== NETWORK OPERATIONS ===

HTTP Operations:
- Use send_request_cgi() for web requests
- Use send_request_raw() when full control needed
- Always check response before accessing properties
- Set appropriate timeouts via datastore['HttpClientTimeout']

TCP Operations:
- Use connect() and disconnect() for socket management
- Always disconnect in ensure blocks or cleanup methods
- Set socket timeouts via datastore options
- Handle connection failures gracefully with meaningful messages

Resource Management:
- Close connections in ensure blocks
- Use framework disconnect helpers
- Clean up even on error conditions

=== PAYLOAD DELIVERY ===

Pre-Delivery Checks:
- Verify available buffer/memory space for payload
- Check target architecture compatibility
- Identify bad characters that must be avoided
- Select appropriate encoder if needed

Payload Integration:
- Use payload.encoded for encoded payload data
- Use payload.encoded_exe for executable generation
- Verify payload generation succeeded before sending
- Handle payload generation failures gracefully

=== RESOURCE CLEANUP ===

Required Cleanup:
- Disconnect all network sockets
- Register temporary files for deletion via register_file_for_cleanup()
- Remove uploaded files or artifacts when possible
- Close file handles and resources

Cleanup Patterns:
- Use ensure blocks for guaranteed cleanup
- Implement cleanup_handler() method for complex cleanup
- Log cleanup failures but don't stop execution
- Clean up even when exploitation fails

=== TESTING CONSIDERATIONS ===

Check Command Support:
- Implement check() method returning CheckCode constants
- CheckCode::Appears - strong indicators of vulnerability
- CheckCode::Detected - service/version detected
- CheckCode::Safe - not vulnerable
- CheckCode::Unknown - cannot determine
- CheckCode::Unsupported - check not implemented

Compatibility:
- Support verbose mode with additional debug output
- Handle different target configurations gracefully
- Test against multiple versions when applicable
- Validate with different payload types

=== DOCUMENTATION STANDARDS ===

Code Comments:
- Explain WHY code exists, not WHAT it does
- Document non-obvious logic and edge cases
- Reference specifications or documentation
- Avoid redundant comments that restate code

Module Description:
- Clearly describe the vulnerability being exploited
- Specify affected versions and conditions
- Include example usage scenarios
- Note any limitations or requirements
- Provide command examples when helpful

Author Attribution:
- Credit original vulnerability discoverers
- Credit exploit developers
- Credit module contributors
- Include contact information when appropriate