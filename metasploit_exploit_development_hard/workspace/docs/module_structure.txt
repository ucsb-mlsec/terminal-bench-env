# METASPLOIT FRAMEWORK MODULE STRUCTURE DOCUMENTATION

## 1. MODULE CLASS HIERARCHY

Metasploit exploit modules are organized in a hierarchical class structure that determines their behavior and capabilities.

### Base Classes:
- **Msf::Exploit::Remote**: Used for network-based exploits that target remote services. This is the most common base class for exploits targeting network services, web applications, or any remotely accessible vulnerability.
- **Msf::Exploit::Local**: Used for privilege escalation or local exploits that execute on a system where you already have access. These modules typically target kernel vulnerabilities, misconfigured services, or privilege escalation paths.
- **Msf::Auxiliary**: For modules that don't deliver payloads (scanners, DoS, information gathering)
- **Msf::Post**: For post-exploitation modules that run after initial compromise

The choice of base class affects what mixins are available and how the exploit interacts with targets.

## 2. REQUIRED METHODS

Every Metasploit exploit module must implement specific methods to function properly:

### initialize Method:
This method sets up all module metadata. Required fields include:

- **Name**: Short, descriptive title of the exploit (under 60 characters)
- **Description**: Detailed explanation of what the exploit does, what it targets, and any special considerations
- **Author**: Array of author names/handles. Format: ['Author Name <email>', 'Handle']
- **License**: Always set to MSF_LICENSE (BSD-based license)
- **References**: Array of reference hashes documenting the vulnerability
- **Platform**: Target platform(s) - 'win', 'linux', 'unix', 'osx', etc.
- **Arch**: Target architecture(s) - ARCH_X86, ARCH_X64, ARCH_MIPS, etc.
- **Targets**: Array of target definitions with specific configurations
- **DefaultTarget**: Index of default target in Targets array
- **Payload**: Payload space/badchars configuration
- **DisclosureDate**: When vulnerability was publicly disclosed (format: 'YYYY-MM-DD')

### check Method:
Optional but highly recommended. Verifies if target is vulnerable without exploiting.
Returns CheckCode constants:
- **CheckCode::Appears**: Strong evidence target is vulnerable
- **CheckCode::Detected**: Target is running vulnerable software
- **CheckCode::Safe**: Confirmed not vulnerable
- **CheckCode::Unsupported**: Cannot check this target type
- **CheckCode::Unknown**: Unable to determine vulnerability status

### exploit Method:
Contains the main exploitation logic. This is where the actual attack occurs, including:
- Vulnerability triggering
- Payload delivery
- Session establishment
- Cleanup operations

## 3. COMMON MIXINS

Mixins add functionality to exploit modules:

### Msf::Exploit::Remote::HttpClient
Provides HTTP/HTTPS communication capabilities. Includes methods:
- send_request_cgi(): Send HTTP requests with parsed parameters
- send_request_raw(): Send raw HTTP requests
- normalize_uri(): Properly format URI paths
Automatically registers RHOST, RPORT, VHOST, SSL options.

### Msf::Exploit::Remote::Tcp
Low-level TCP socket operations:
- connect(): Establish TCP connection
- disconnect(): Close connection
- sock: Access to the connected socket object
Registers RHOST, RPORT options automatically.

### Msf::Exploit::CmdStager
Stages command execution through multiple small commands:
- execute_cmdstager(): Main staging method
- flavor option: Determines staging technique (certutil, echo, printf, etc.)
Useful when payload space is limited or special characters are filtered.

### Msf::Exploit::FileDropper
Tracks files created during exploitation for cleanup:
- register_file_for_cleanup(): Mark files for deletion
- cleanup(): Automatically called after exploitation
Ensures forensic artifacts are minimized.

### Msf::Exploit::EXE
Generate executable payloads:
- generate_payload_exe(): Create Windows/Linux executables
Handles multiple executable formats.

### Msf::Exploit::FILEFORMAT
For exploits targeting file format parsers:
- Handles file generation and delivery
- Manages filename extensions

## 4. REGISTER OPTIONS

Options configure module behavior. Defined in register_options() using Option classes:

### Option Types:
- **OptString**: String values. OptString.new('OPTION_NAME', [required, 'Description', default_value])
- **OptInt**: Integer values. OptInt.new('OPTION_NAME', [required, 'Description', default_value])
- **OptBool**: Boolean true/false. OptBool.new('OPTION_NAME', [required, 'Description', default_value])
- **OptPath**: Filesystem paths. OptPath.new('OPTION_NAME', [required, 'Description', default_value])
- **OptAddress**: IP addresses. OptAddress.new('OPTION_NAME', [required, 'Description', default_value])
- **OptPort**: Port numbers with validation. OptPort.new('OPTION_NAME', [required, 'Description', default_value])
- **OptEnum**: Enumerated choices. OptEnum.new('OPTION_NAME', [required, 'Description', default, ['choice1', 'choice2']])

Required vs Optional: First parameter after name is boolean indicating if required.

Access values via: datastore['OPTION_NAME']

## 5. METADATA FIELDS

### Author Array:
Multiple formats supported:
- 'Name': Simple attribution
- 'Name <email@domain.com>': With contact info
- 'Handle': Anonymous/pseudonymous attribution
- 'Name', 'Name2': Multiple contributors

### References Array:
Documents vulnerability sources:
- ['CVE', 'YYYY-NNNN']: Common Vulnerabilities and Exposures ID
- ['BID', 'NUMBER']: Bugtraq ID
- ['URL', 'https://...']: Web references
- ['EDB', 'NUMBER']: Exploit Database ID
- ['OSVDB', 'NUMBER']: Open Source Vulnerability Database (legacy)

### License:
Always use MSF_LICENSE constant. Never use other license values.

### DisclosureDate:
Format: 'YYYY-MM-DD' (ISO 8601 date format)
Date when vulnerability became public knowledge.

### Privileged:
Boolean indicating if exploit grants elevated privileges.

### DefaultOptions:
Hash of default option values, useful for pre-configuring common settings.

## 6. TARGET STRUCTURE

Targets array defines specific configurations for different scenarios:

```ruby
'Targets' => [
  [
    'Target Name',
    {
      'Arch' => ARCH_X86,
      'Platform' => 'win',
      'Ret' => 0x12345678,  # Return address
      'Offset' => 1234       # Buffer offset
    }
  ]
]
```

Keys:
- **Arch**: Architecture constant (ARCH_X86, ARCH_X64)
- **Platform**: OS platform string
- **Ret**: Return address for exploitation
- **Offset**: Buffer offset or other numeric configuration
- Custom keys: Add target-specific parameters as needed

Access current target via: target (returns hash), target.name, target['Ret']

## 7. HELPER METHODS

### Logging Methods:
- **print_status(msg)**: Informational messages (blue)
- **print_good(msg)**: Success messages (green)
- **print_error(msg)**: Error messages (red)
- **print_warning(msg)**: Warning messages (yellow)
- **vprint_status/good/error/warning**: Verbose logging (only with VERBOSE=true)

### Failure Handling:
- **fail_with(reason, msg)**: Terminate exploit with specific failure reason
  Reasons: Failure::Unknown, Failure::BadConfig, Failure::Unreachable, 
  Failure::NotVulnerable, Failure::PayloadFailed

### File Management:
- **register_file_for_cleanup(filepath)**: Mark files for deletion after exploitation

### Session Management:
- **handler(client)**: Process new session
- **cleanup()**: Called after exploitation for resource cleanup

## 8. PAYLOAD INTEGRATION

### Accessing Payload:
- **payload.encoded**: Raw payload bytes with encoding applied
- **payload.raw**: Unencoded payload
- **payload.space**: Available payload space

### Generating Payloads:
- **generate_payload_exe()**: Create standalone executable
- **regenerate_payload(target_specific_options)**: Generate payload with target-specific parameters
- **payload_instance**: Access payload module instance

### Payload Space Configuration:
Defined in initialize():
```ruby
'Payload' => {
  'Space' => 1024,
  'BadChars' => "\x00\x0a\x0d",
  'DisableNops' => true
}
```

## 9. BEST PRACTICES

### Error Handling:
- Always validate user input from datastore options
- Use fail_with() for graceful failure with meaningful messages
- Catch exceptions and provide context
- Check return values from network operations

### Logging:
- Use print_status for major steps
- Use vprint_status for detailed debugging information
- Always log successful exploitation with print_good
- Log failures with print_error before failing

### Cleanup:
- Register created files with register_file_for_cleanup
- Implement cleanup() method to remove artifacts
- Close network connections in ensure blocks
- Restore modified configurations when possible

### Datastore Usage:
- Access configuration: datastore['OPTION']
- Validate before use: fail_with(Failure::BadConfig) if invalid
- Provide sensible defaults in register_options
- Document expected values in option descriptions

### Code Organization:
- Break complex exploits into helper methods
- Keep exploit() method focused on main logic flow
- Document non-obvious implementation details
- Use meaningful variable and method names

### Testing:
- Always implement check() method when possible
- Test against multiple target versions
- Verify cleanup functionality
- Test failure conditions

### Security Considerations:
- Never include actual exploit code for 0-days
- Respect disclosure timelines
- Document patch availability
- Consider impact on production systems