I'll create the required files for this Vault unseal automation system.

First, the data file with unseal keys:

**File: data/vault-keys.enc**

dGhpc0lzQVZhdWx0VW5zZWFsS2V5U2hhcmUxMjM0NTY3ODkwYWJjZGVmZ2hpams=
QkFTRTY0RW5jb2RlZFVuc2VhbEtleVNoYXJlMlZhdWx0U2VjdXJpdHlLZXlBQkM=
VmF1bHRVbnNlYWxTaGFyZTNTZWN1cmVLZXlEYXRhMTIzNDU2Nzg5MHF3ZXJ0eXVpb3A=

**File: /opt/vault/generate-unseal-script.py**

```python
#!/usr/bin/env python3

import json
import os
import stat

CONFIG_FILE = "/etc/vault/config.json"
OUTPUT_SCRIPT = "/opt/vault/unseal-vault.sh"

def generate_unseal_script():
    # Read configuration
    with open(CONFIG_FILE, 'r') as f:
        config = json.load(f)
    
    nodes = config['nodes']
    unseal_keys_file = config['unseal_keys_file']
    required_shares = config['required_shares']
    timeout_seconds = config['timeout_seconds']
    
    # Generate the bash script
    script_content = f'''#!/bin/bash

# Vault Unseal Automation Script
# Generated by generate-unseal-script.py
# DO NOT EDIT THIS FILE DIRECTLY - Regenerate using the generator

set -euo pipefail

# Configuration
UNSEAL_KEYS_FILE="{unseal_keys_file}"
REQUIRED_SHARES={required_shares}
TIMEOUT_SECONDS={timeout_seconds}
LOG_FILE="/var/log/vault-unseal.log"

# Color codes for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

# Logging function
log() {{
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $1"
}}

# Check if node is sealed
check_sealed_status() {{
    local node_address="$1"
    local response
    
    response=$(curl -sk --max-time 10 "$node_address/v1/sys/seal-status" 2>/dev/null || echo "")
    
    if [ -z "$response" ]; then
        echo "error"
        return
    fi
    
    local sealed=$(echo "$response" | grep -o '"sealed":[^,]*' | cut -d':' -f2 | tr -d ' ')
    
    if [ "$sealed" = "true" ]; then
        echo "sealed"
    elif [ "$sealed" = "false" ]; then
        echo "unsealed"
    else
        echo "error"
    fi
}}

# Unseal a single node
unseal_node() {{
    local node_name="$1"
    local node_address="$2"
    local keys_file="$3"
    local required="$4"
    
    log "Processing node: $node_name ($node_address)"
    
    # Check current seal status
    local status=$(check_sealed_status "$node_address")
    
    if [ "$status" = "error" ]; then
        log "  ${{RED}}ERROR: Cannot connect to $node_name${{NC}}"
        return 1
    fi
    
    if [ "$status" = "unsealed" ]; then
        log "  ${{GREEN}}SKIP: $node_name is already unsealed${{NC}}"
        return 0
    fi
    
    log "  Node is sealed, proceeding with unseal operation"
    
    # Read unseal keys
    local key_count=0
    local success=0
    
    while IFS= read -r key && [ $key_count -lt $required ]; do
        if [ -z "$key" ]; then
            continue
        fi
        
        key_count=$((key_count + 1))
        log "  Applying unseal key share $key_count of $required"
        
        local response
        response=$(curl -sk --max-time 10 \\
            -X PUT \\
            -H "Content-Type: application/json" \\
            -d "{{\\"key\\": \\"$key\\"}}" \\
            "$node_address/v1/sys/unseal" 2>/dev/null || echo "")
        
        if [ -z "$response" ]; then
            log "  ${{RED}}ERROR: Failed to apply key share $key_count${{NC}}"
            return 1
        fi
        
        # Check if unsealed after this key
        local sealed=$(echo "$response" | grep -o '"sealed":[^,]*' | cut -d':' -f2 | tr -d ' ')
        if [ "$sealed" = "false" ]; then
            log "  ${{GREEN}}SUCCESS: $node_name unsealed after $key_count shares${{NC}}"
            return 0
        fi
    done < "$keys_file"
    
    # Check final status
    status=$(check_sealed_status "$node_address")
    if [ "$status" = "unsealed" ]; then
        log "  ${{GREEN}}SUCCESS: $node_name is now unsealed${{NC}}"
        return 0
    else
        log "  ${{RED}}ERROR: $node_name remains sealed after applying $key_count keys${{NC}}"
        return 1
    fi
}}

# Main execution
main() {{
    local start_time=$(date +%s)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    
    log "=========================================="
    log "Starting Vault Unseal Process"
    log "Timestamp: $timestamp"
    log "Timeout: $TIMEOUT_SECONDS seconds"
    log "=========================================="
    
    # Check if keys file exists
    if [ ! -f "$UNSEAL_KEYS_FILE" ]; then
        log "${{RED}}ERROR: Unseal keys file not found: $UNSEAL_KEYS_FILE${{NC}}"
        echo "timestamp=$timestamp unsealed=0 total={len(nodes)} success=false" >> "$LOG_FILE"
        exit 1
    fi
    
    local total_nodes={len(nodes)}
    local unsealed_count=0
    local failed_nodes=()
    
    # Process each node
'''
    
    # Add each node to the script
    for node in nodes:
        script_content += f'''
    if unseal_node "{node['name']}" "{node['address']}" "$UNSEAL_KEYS_FILE" "$REQUIRED_SHARES"; then
        unsealed_count=$((unsealed_count + 1))
    else
        failed_nodes+=("{node['name']}")
    fi
    
    # Check timeout
    local current_time=$(date +%s)
    local elapsed=$((current_time - start_time))
    if [ $elapsed -ge $TIMEOUT_SECONDS ]; then
        log "${{YELLOW}}WARNING: Timeout reached ($TIMEOUT_SECONDS seconds)${{NC}}"
        break
    fi
'''
    
    script_content += f'''
    
    # Summary
    log "=========================================="
    log "Unseal Process Complete"
    log "Successfully unsealed: $unsealed_count/$total_nodes nodes"
    
    if [ ${{#failed_nodes[@]}} -gt 0 ]; then
        log "${{RED}}Failed nodes: ${{failed_nodes[*]}}${{NC}}"
    fi
    
    # Determine success
    local success="false"
    if [ $unsealed_count -eq $total_nodes ]; then
        success="true"
        log "${{GREEN}}All nodes successfully unsealed${{NC}}"
    else
        log "${{YELLOW}}Partial unseal: $unsealed_count/$total_nodes nodes${{NC}}"
    fi
    
    log "=========================================="
    
    # Write status to log file
    echo "timestamp=$timestamp unsealed=$unsealed_count total=$total_nodes success=$success" >> "$LOG_FILE"
    
    # Exit with appropriate code
    if [ "$success" = "true" ]; then
        exit 0
    else
        exit 1
    fi
}}

# Run main function
main
'''
    
    # Write the script
    os.makedirs(os.path.dirname(OUTPUT_SCRIPT), exist_ok=True)
    with open(OUTPUT_SCRIPT, 'w') as f:
        f.write(script_content)
    
    # Make executable
    st = os.stat(OUTPUT_SCRIPT)
    os.chmod(OUTPUT_SCRIPT, st.st_mode | stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH)
    
    print(f"Successfully generated unseal script: {OUTPUT_SCRIPT}")
    print(f"Total nodes configured: {len(nodes)}")
    print(f"Required unseal shares: {required_shares}")
    print(f"Timeout: {timeout_seconds} seconds")

if __name__ == "__main__":
    generate_unseal_script()
```

This solution creates a Python script generator that produces a robust bash script for automating Vault unsealing. The generated script handles all required scenarios including checking seal status, skipping already-unsealed nodes, applying key shares sequentially, handling timeouts, and logging results in the exact format specified.