#!/bin/bash

# Create the workspace structure
mkdir -p /workspace/project/videos
mkdir -p /workspace/project/images
mkdir -p /workspace/project/docs
mkdir -p /workspace/backup/videos
mkdir -p /workspace/backup/images

# Create some regular files in project
echo "This is a regular text file" > /workspace/project/docs/readme.txt
echo "# Project Documentation" > /workspace/project/docs/manual.md

# Create LFS pointer files in project
cat > /workspace/project/videos/demo.mp4 << 'EOF'
version https://git-lfs.github.com/spec/v1
oid sha256:4d7a214614ab2935c943f9e0ff69d22ebbe855502b0b730d6c4e0ba8d1c8e2c2
size 10485760
EOF

cat > /workspace/project/videos/tutorial.mp4 << 'EOF'
version https://git-lfs.github.com/spec/v1
oid sha256:5e8b325715bc3046d954f0fe60cd33dfccf946613c1c841e7d5f1c9e2d9f3e3e
size 8388608
EOF

cat > /workspace/project/images/logo.png << 'EOF'
version https://git-lfs.github.com/spec/v1
oid sha256:6f9c436826cd4157e065g1gf71de44efddga57724d2d952f8e6g2daf3eag4f4f
size 2097152
EOF

cat > /workspace/project/images/banner.jpg << 'EOF'
version https://git-lfs.github.com/spec/v1
oid sha256:7gad547937de5268f176h2hg82ef55fgeehb68835e3e063g9f7h3ebg4fbh5g5g
size 1048576
EOF

cat > /workspace/project/docs/presentation.pptx << 'EOF'
version https://git-lfs.github.com/spec/v1
oid sha256:8hbe658a48ef6379g287i3ih93fg66ghffic79946f4f174hagh4fchi6gci6h6h
size 5242880
EOF

# Generate binary MP4 file for backup (demo.mp4)
python3 << 'PYEOF'
import struct
import os

output_file = '/workspace/backup/videos/demo.mp4'
target_size = 10485760  # 10MB

with open(output_file, 'wb') as f:
    # ftyp box (file type box)
    ftyp_size = 32
    f.write(struct.pack('>I', ftyp_size))  # box size
    f.write(b'ftyp')  # box type
    f.write(b'isom')  # major brand
    f.write(struct.pack('>I', 512))  # minor version
    f.write(b'isomiso2avc1mp41')  # compatible brands
    
    # moov box (movie metadata box)
    moov_size = 1024
    f.write(struct.pack('>I', moov_size))
    f.write(b'moov')
    
    # mvhd (movie header) inside moov
    mvhd_size = 108
    f.write(struct.pack('>I', mvhd_size))
    f.write(b'mvhd')
    f.write(struct.pack('>I', 0))  # version and flags
    f.write(struct.pack('>I', 0))  # creation time
    f.write(struct.pack('>I', 0))  # modification time
    f.write(struct.pack('>I', 1000))  # timescale
    f.write(struct.pack('>I', 30000))  # duration
    f.write(struct.pack('>I', 0x00010000))  # rate
    f.write(struct.pack('>H', 0x0100))  # volume
    f.write(b'\x00' * 10)  # reserved
    # transformation matrix
    for val in [0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000]:
        f.write(struct.pack('>I', val))
    f.write(b'\x00' * 24)  # pre-defined
    f.write(struct.pack('>I', 2))  # next track ID
    
    # Fill rest of moov box
    moov_remaining = moov_size - 4 - 4 - mvhd_size
    f.write(b'\x00' * moov_remaining)
    
    # mdat box (media data box) - contains actual video data
    current_pos = ftyp_size + moov_size
    mdat_data_size = target_size - current_pos - 8
    mdat_size = mdat_data_size + 8
    
    f.write(struct.pack('>I', mdat_size))
    f.write(b'mdat')
    
    # Fill with pseudo-random binary data simulating video frames
    chunk_size = 65536
    written = 0
    seed = 0x12345678
    
    while written < mdat_data_size:
        to_write = min(chunk_size, mdat_data_size - written)
        # Generate pseudo-random data
        chunk = bytearray()
        for i in range(to_write):
            seed = (seed * 1103515245 + 12345) & 0x7fffffff
            chunk.append(seed & 0xFF)
        f.write(bytes(chunk))
        written += to_write

print(f"Generated {output_file}")
PYEOF

# Generate binary PNG file for backup (logo.png)
python3 << 'PYEOF'
import struct
import zlib

output_file = '/workspace/backup/images/logo.png'

with open(output_file, 'wb') as f:
    # PNG signature
    f.write(b'\x89PNG\r\n\x1a\n')
    
    # IHDR chunk (image header)
    width, height = 1024, 768
    ihdr_data = struct.pack('>IIBBBBB', width, height, 8, 2, 0, 0, 0)
    ihdr_crc = zlib.crc32(b'IHDR' + ihdr_data)
    f.write(struct.pack('>I', 13))  # length
    f.write(b'IHDR')
    f.write(ihdr_data)
    f.write(struct.pack('>I', ihdr_crc))
    
    # IDAT chunk (image data)
    # Create RGB image data
    row_bytes = width * 3 + 1  # 3 bytes per pixel + filter byte
    image_data = bytearray()
    for y in range(height):
        image_data.append(0)  # filter type (none)
        for x in range(width):
            # Create gradient pattern
            r = (x * 255) // width
            g = (y * 255) // height
            b = 128
            image_data.extend([r, g, b])
    
    compressed_data = zlib.compress(bytes(image_data), 9)
    idat_crc = zlib.crc32(b'IDAT' + compressed_data)
    f.write(struct.pack('>I', len(compressed_data)))
    f.write(b'IDAT')
    f.write(compressed_data)
    f.write(struct.pack('>I', idat_crc))
    
    # IEND chunk (end of file)
    iend_crc = zlib.crc32(b'IEND')
    f.write(struct.pack('>I', 0))
    f.write(b'IEND')
    f.write(struct.pack('>I', iend_crc))

print(f"Generated {output_file}")
PYEOF

# Generate binary JPG file for backup (banner.jpg)
python3 << 'PYEOF'
output_file = '/workspace/backup/images/banner.jpg'
target_size = 1048576  # 1MB

with open(output_file, 'wb') as f:
    # JPEG header
    f.write(b'\xFF\xD8\xFF\xE0')  # SOI + APP0
    f.write(b'\x00\x10')  # APP0 length
    f.write(b'JFIF\x00')  # JFIF identifier
    f.write(b'\x01\x01')  # JFIF version
    f.write(b'\x00')  # density units
    f.write(b'\x00\x01\x00\x01')  # X and Y density
    f.write(b'\x00\x00')  # thumbnail dimensions
    
    # DQT (Define Quantization Table)
    f.write(b'\xFF\xDB')
    f.write(b'\x00\x43')  # length
    f.write(b'\x00')  # table ID
    # Standard quantization table
    qtable = bytes([16, 11, 10, 16, 24, 40, 51, 61,
                    12, 12, 14, 19, 26, 58, 60, 55,
                    14, 13, 16, 24, 40, 57, 69, 56,
                    14, 17, 22, 29, 51, 87, 80, 62,
                    18, 22, 37, 56, 68, 109, 103, 77,
                    24, 35, 55, 64, 81, 104, 113, 92,
                    49, 64, 78, 87, 103, 121, 120, 101,
                    72, 92, 95, 98, 112, 100, 103, 99])
    f.write(qtable)
    
    # SOF0 (Start of Frame)
    f.write(b'\xFF\xC0')
    f.write(b'\x00\x11')  # length
    f.write(b'\x08')  # precision
    f.write(b'\x04\x00')  # height (1024)
    f.write(b'\x06\x00')  # width (1536)
    f.write(b'\x03')  # number of components
    f.write(b'\x01\x22\x00')  # Y component
    f.write(b'\x02\x11\x01')  # Cb component
    f.write(b'\x03\x11\x01')  # Cr component
    
    # DHT (Define Huffman Table) - simplified
    f.write(b'\xFF\xC4')
    f.write(b'\x00\x1F')  # length
    f.write(b'\x00')  # table class and ID
    f.write(b'\x00\x01\x05\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00')
    f.write(b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B')
    
    # SOS (Start of Scan)
    f.write(b'\xFF\xDA')
    f.write(b'\x00\x0C')  # length
    f.write(b'\x03')  # number of components
    f.write(b'\x01\x00')  # Y component
    f.write(b'\x02\x11')  # Cb component
    f.write(b'\x03\x11')  # Cr component
    f.write(b'\x00\x3F\x00')  # spectral selection
    
    # Fill with compressed image data
    current_size = f.tell()
    remaining = target_size - current_size - 2  # -2 for EOI marker
    
    # Generate pseudo-compressed data (avoiding 0xFF sequences that need escaping)
    import random
    random.seed(42)
    for _ in range(remaining):
        byte = random.randint(0, 254)  # Avoid 0xFF
        f.write(bytes([byte]))
    
    # EOI (End of Image)
    f.write(b'\xFF\xD9')

print(f"Generated {output_file}")
PYEOF

# Now create the restoration script
python3 << 'PYEOF'
import os
import sys

def is_lfs_pointer(filepath):
    """Check if a file is an LFS pointer file"""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
            first_line = f.readline().strip()
            return first_line == "version https://git-lfs.github.com/spec/v1"
    except:
        return False

def find_lfs_pointers(root_dir):
    """Recursively find all LFS pointer files"""
    pointers = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            if is_lfs_pointer(filepath):
                pointers.append(filepath)
    return pointers

def get_relative_path(filepath, base_dir):
    """Get relative path from base directory"""
    return os.path.relpath(filepath, base_dir)

def restore_file(pointer_path, project_dir, backup_dir):
    """Restore a pointer file from backup"""
    rel_path = get_relative_path(pointer_path, project_dir)
    backup_path = os.path.join(backup_dir, rel_path)
    
    if os.path.exists(backup_path) and os.path.isfile(backup_path):
        # Copy backup file to project location
        with open(backup_path, 'rb') as src:
            content = src.read()
        with open(pointer_path, 'wb') as dst:
            dst.write(content)
        return True
    return False

# Main execution
project_dir = '/workspace/project'
backup_dir = '/workspace/backup'

# Find all LFS pointer files
pointer_files = find_lfs_pointers(project_dir)
found_count = len(pointer_files)

# Restore each pointer file
restored_count = 0
failed_count = 0

for pointer_file in pointer_files:
    if restore_file(pointer_file, project_dir, backup_dir):
        restored_count += 1
    else:
        failed_count += 1

# Write results
with open('/workspace/result.txt', 'w') as f:
    f.write(f"FOUND={found_count}\n")
    f.write(f"RESTORED={restored_count}\n")
    f.write(f"FAILED={failed_count}\n")

print(f"Found {found_count} LFS pointer files")
print(f"Restored {restored_count} files")
print(f"Failed to restore {failed_count} files")
PYEOF